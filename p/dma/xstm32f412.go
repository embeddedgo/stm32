// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32f412

package dma

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ISR  [2]mmio.R32[ISR]
	IFCR [2]mmio.R32[IFCR]
	S    [8]SS
}

func DMA1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.DMA1_BASE))) }
func DMA2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.DMA2_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	return bus.AHB1
}

type ISR uint32

func FEIF0_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: FEIF0} }
func DMEIF0_(p *Periph, i int) mmio.RM32[ISR] { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: DMEIF0} }
func TEIF0_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TEIF0} }
func HTIF0_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: HTIF0} }
func TCIF0_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TCIF0} }
func FEIF1_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: FEIF1} }
func DMEIF1_(p *Periph, i int) mmio.RM32[ISR] { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: DMEIF1} }
func TEIF1_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TEIF1} }
func HTIF1_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: HTIF1} }
func TCIF1_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TCIF1} }
func FEIF2_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: FEIF2} }
func DMEIF2_(p *Periph, i int) mmio.RM32[ISR] { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: DMEIF2} }
func TEIF2_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TEIF2} }
func HTIF2_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: HTIF2} }
func TCIF2_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TCIF2} }
func FEIF3_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: FEIF3} }
func DMEIF3_(p *Periph, i int) mmio.RM32[ISR] { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: DMEIF3} }
func TEIF3_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TEIF3} }
func HTIF3_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: HTIF3} }
func TCIF3_(p *Periph, i int) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR[i], Mask: TCIF3} }

type IFCR uint32

func CFEIF0_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CFEIF0} }
func CDMEIF0_(p *Periph, i int) mmio.RM32[IFCR] { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CDMEIF0} }
func CTEIF0_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTEIF0} }
func CHTIF0_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CHTIF0} }
func CTCIF0_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTCIF0} }
func CFEIF1_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CFEIF1} }
func CDMEIF1_(p *Periph, i int) mmio.RM32[IFCR] { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CDMEIF1} }
func CTEIF1_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTEIF1} }
func CHTIF1_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CHTIF1} }
func CTCIF1_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTCIF1} }
func CFEIF2_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CFEIF2} }
func CDMEIF2_(p *Periph, i int) mmio.RM32[IFCR] { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CDMEIF2} }
func CTEIF2_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTEIF2} }
func CHTIF2_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CHTIF2} }
func CTCIF2_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTCIF2} }
func CFEIF3_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CFEIF3} }
func CDMEIF3_(p *Periph, i int) mmio.RM32[IFCR] { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CDMEIF3} }
func CTEIF3_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTEIF3} }
func CHTIF3_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CHTIF3} }
func CTCIF3_(p *Periph, i int) mmio.RM32[IFCR]  { return mmio.RM32[IFCR]{R: &p.IFCR[i], Mask: CTCIF3} }

type SS struct {
	CR   mmio.R32[CR]
	NDTR mmio.R32[NDTR]
	PAR  mmio.R32[PAR]
	M0AR mmio.R32[M0AR]
	M1AR mmio.R32[M1AR]
	FCR  mmio.R32[FCR]
}

type CR uint32

func EN_(p *Periph, i int) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: EN} }
func DMEIE_(p *Periph, i int) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: DMEIE} }
func TEIE_(p *Periph, i int) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: TEIE} }
func HTIE_(p *Periph, i int) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: HTIE} }
func TCIE_(p *Periph, i int) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: TCIE} }
func PFCTRL_(p *Periph, i int) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: PFCTRL} }
func DIR_(p *Periph, i int) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: DIR} }
func CIRC_(p *Periph, i int) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: CIRC} }
func PINC_(p *Periph, i int) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: PINC} }
func MINC_(p *Periph, i int) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: MINC} }
func PSIZE_(p *Periph, i int) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: PSIZE} }
func MSIZE_(p *Periph, i int) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: MSIZE} }
func PINCOS_(p *Periph, i int) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: PINCOS} }
func PL_(p *Periph, i int) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: PL} }
func DBM_(p *Periph, i int) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: DBM} }
func CT_(p *Periph, i int) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: CT} }
func PBURST_(p *Periph, i int) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: PBURST} }
func MBURST_(p *Periph, i int) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: MBURST} }
func CHSEL_(p *Periph, i int) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.S[i].CR, Mask: CHSEL} }

type NDTR uint32

func NDT_(p *Periph, i int) mmio.RM32[NDTR] { return mmio.RM32[NDTR]{R: &p.S[i].NDTR, Mask: NDT} }

type PAR uint32

func PA_(p *Periph, i int) mmio.RM32[PAR] { return mmio.RM32[PAR]{R: &p.S[i].PAR, Mask: PA} }

type M0AR uint32

func M0A_(p *Periph, i int) mmio.RM32[M0AR] { return mmio.RM32[M0AR]{R: &p.S[i].M0AR, Mask: M0A} }

type M1AR uint32

func M1A_(p *Periph, i int) mmio.RM32[M1AR] { return mmio.RM32[M1AR]{R: &p.S[i].M1AR, Mask: M1A} }

type FCR uint32

func FTH_(p *Periph, i int) mmio.RM32[FCR]   { return mmio.RM32[FCR]{R: &p.S[i].FCR, Mask: FTH} }
func DMDIS_(p *Periph, i int) mmio.RM32[FCR] { return mmio.RM32[FCR]{R: &p.S[i].FCR, Mask: DMDIS} }
func FS_(p *Periph, i int) mmio.RM32[FCR]    { return mmio.RM32[FCR]{R: &p.S[i].FCR, Mask: FS} }
func FEIE_(p *Periph, i int) mmio.RM32[FCR]  { return mmio.RM32[FCR]{R: &p.S[i].FCR, Mask: FEIE} }
