// DO NOT EDIT THIS FILE. GENERATED BY xgen.

// +build stm32l4x6

package dma

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ISR   RISR
	IFCR  RIFCR
	C     [7]RC
	_     [5]uint32
	CSELR RCSELR
}

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	return bus.AHB1
}

func DMA1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.DMA1_BASE))) }
func DMA2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.DMA2_BASE))) }

type ISR uint32

type RISR struct{ mmio.U32 }

func (r *RISR) LoadBits(mask ISR) ISR { return ISR(r.U32.LoadBits(uint32(mask))) }
func (r *RISR) StoreBits(mask, b ISR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RISR) SetBits(mask ISR)      { r.U32.SetBits(uint32(mask)) }
func (r *RISR) ClearBits(mask ISR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RISR) Load() ISR             { return ISR(r.U32.Load()) }
func (r *RISR) Store(b ISR)           { r.U32.Store(uint32(b)) }

type RMISR struct{ mmio.UM32 }

func (rm RMISR) Load() ISR   { return ISR(rm.UM32.Load()) }
func (rm RMISR) Store(b ISR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) GIF1() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF1)}}
}

func (p *Periph) TCIF1() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF1)}}
}

func (p *Periph) HTIF1() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF1)}}
}

func (p *Periph) TEIF1() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF1)}}
}

func (p *Periph) GIF2() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF2)}}
}

func (p *Periph) TCIF2() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF2)}}
}

func (p *Periph) HTIF2() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF2)}}
}

func (p *Periph) TEIF2() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF2)}}
}

func (p *Periph) GIF3() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF3)}}
}

func (p *Periph) TCIF3() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF3)}}
}

func (p *Periph) HTIF3() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF3)}}
}

func (p *Periph) TEIF3() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF3)}}
}

func (p *Periph) GIF4() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF4)}}
}

func (p *Periph) TCIF4() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF4)}}
}

func (p *Periph) HTIF4() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF4)}}
}

func (p *Periph) TEIF4() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF4)}}
}

func (p *Periph) GIF5() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF5)}}
}

func (p *Periph) TCIF5() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF5)}}
}

func (p *Periph) HTIF5() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF5)}}
}

func (p *Periph) TEIF5() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF5)}}
}

func (p *Periph) GIF6() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF6)}}
}

func (p *Periph) TCIF6() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF6)}}
}

func (p *Periph) HTIF6() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF6)}}
}

func (p *Periph) TEIF6() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF6)}}
}

func (p *Periph) GIF7() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(GIF7)}}
}

func (p *Periph) TCIF7() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TCIF7)}}
}

func (p *Periph) HTIF7() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(HTIF7)}}
}

func (p *Periph) TEIF7() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(TEIF7)}}
}

type IFCR uint32

type RIFCR struct{ mmio.U32 }

func (r *RIFCR) LoadBits(mask IFCR) IFCR { return IFCR(r.U32.LoadBits(uint32(mask))) }
func (r *RIFCR) StoreBits(mask, b IFCR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIFCR) SetBits(mask IFCR)       { r.U32.SetBits(uint32(mask)) }
func (r *RIFCR) ClearBits(mask IFCR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RIFCR) Load() IFCR              { return IFCR(r.U32.Load()) }
func (r *RIFCR) Store(b IFCR)            { r.U32.Store(uint32(b)) }

type RMIFCR struct{ mmio.UM32 }

func (rm RMIFCR) Load() IFCR   { return IFCR(rm.UM32.Load()) }
func (rm RMIFCR) Store(b IFCR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) CGIF1() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF1)}}
}

func (p *Periph) CTCIF1() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF1)}}
}

func (p *Periph) CHTIF1() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF1)}}
}

func (p *Periph) CTEIF1() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF1)}}
}

func (p *Periph) CGIF2() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF2)}}
}

func (p *Periph) CTCIF2() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF2)}}
}

func (p *Periph) CHTIF2() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF2)}}
}

func (p *Periph) CTEIF2() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF2)}}
}

func (p *Periph) CGIF3() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF3)}}
}

func (p *Periph) CTCIF3() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF3)}}
}

func (p *Periph) CHTIF3() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF3)}}
}

func (p *Periph) CTEIF3() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF3)}}
}

func (p *Periph) CGIF4() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF4)}}
}

func (p *Periph) CTCIF4() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF4)}}
}

func (p *Periph) CHTIF4() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF4)}}
}

func (p *Periph) CTEIF4() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF4)}}
}

func (p *Periph) CGIF5() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF5)}}
}

func (p *Periph) CTCIF5() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF5)}}
}

func (p *Periph) CHTIF5() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF5)}}
}

func (p *Periph) CTEIF5() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF5)}}
}

func (p *Periph) CGIF6() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF6)}}
}

func (p *Periph) CTCIF6() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF6)}}
}

func (p *Periph) CHTIF6() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF6)}}
}

func (p *Periph) CTEIF6() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF6)}}
}

func (p *Periph) CGIF7() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CGIF7)}}
}

func (p *Periph) CTCIF7() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTCIF7)}}
}

func (p *Periph) CHTIF7() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CHTIF7)}}
}

func (p *Periph) CTEIF7() RMIFCR {
	return RMIFCR{mmio.UM32{&p.IFCR.U32, uint32(CTEIF7)}}
}

type RC struct {
	CR   RCR
	NDTR RNDTR
	PAR  RPAR
	MAR  RMAR
	_    uint32
}

type CR uint32

type RCR struct{ mmio.U32 }

func (r *RCR) LoadBits(mask CR) CR  { return CR(r.U32.LoadBits(uint32(mask))) }
func (r *RCR) StoreBits(mask, b CR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR) SetBits(mask CR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR) ClearBits(mask CR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR) Load() CR             { return CR(r.U32.Load()) }
func (r *RCR) Store(b CR)           { r.U32.Store(uint32(b)) }

type RMCR struct{ mmio.UM32 }

func (rm RMCR) Load() CR   { return CR(rm.UM32.Load()) }
func (rm RMCR) Store(b CR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) EN(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(EN)}}
}

func (p *Periph) TCIE(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(TCIE)}}
}

func (p *Periph) HTIE(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(HTIE)}}
}

func (p *Periph) TEIE(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(TEIE)}}
}

func (p *Periph) DIR(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(DIR)}}
}

func (p *Periph) CIRC(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(CIRC)}}
}

func (p *Periph) PINC(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(PINC)}}
}

func (p *Periph) MINC(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(MINC)}}
}

func (p *Periph) PSIZE(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(PSIZE)}}
}

func (p *Periph) MSIZE(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(MSIZE)}}
}

func (p *Periph) PL(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(PL)}}
}

func (p *Periph) MEM2MEM(n int) RMCR {
	return RMCR{mmio.UM32{&p.C[n].CR.U32, uint32(MEM2MEM)}}
}

type NDTR uint32

type RNDTR struct{ mmio.U32 }

func (r *RNDTR) LoadBits(mask NDTR) NDTR { return NDTR(r.U32.LoadBits(uint32(mask))) }
func (r *RNDTR) StoreBits(mask, b NDTR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RNDTR) SetBits(mask NDTR)       { r.U32.SetBits(uint32(mask)) }
func (r *RNDTR) ClearBits(mask NDTR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RNDTR) Load() NDTR              { return NDTR(r.U32.Load()) }
func (r *RNDTR) Store(b NDTR)            { r.U32.Store(uint32(b)) }

type RMNDTR struct{ mmio.UM32 }

func (rm RMNDTR) Load() NDTR   { return NDTR(rm.UM32.Load()) }
func (rm RMNDTR) Store(b NDTR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) NDT(n int) RMNDTR {
	return RMNDTR{mmio.UM32{&p.C[n].NDTR.U32, uint32(NDT)}}
}

type PAR uint32

type RPAR struct{ mmio.U32 }

func (r *RPAR) LoadBits(mask PAR) PAR { return PAR(r.U32.LoadBits(uint32(mask))) }
func (r *RPAR) StoreBits(mask, b PAR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPAR) SetBits(mask PAR)      { r.U32.SetBits(uint32(mask)) }
func (r *RPAR) ClearBits(mask PAR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPAR) Load() PAR             { return PAR(r.U32.Load()) }
func (r *RPAR) Store(b PAR)           { r.U32.Store(uint32(b)) }

type RMPAR struct{ mmio.UM32 }

func (rm RMPAR) Load() PAR   { return PAR(rm.UM32.Load()) }
func (rm RMPAR) Store(b PAR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) PA(n int) RMPAR {
	return RMPAR{mmio.UM32{&p.C[n].PAR.U32, uint32(PA)}}
}

type MAR uint32

type RMAR struct{ mmio.U32 }

func (r *RMAR) LoadBits(mask MAR) MAR { return MAR(r.U32.LoadBits(uint32(mask))) }
func (r *RMAR) StoreBits(mask, b MAR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RMAR) SetBits(mask MAR)      { r.U32.SetBits(uint32(mask)) }
func (r *RMAR) ClearBits(mask MAR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RMAR) Load() MAR             { return MAR(r.U32.Load()) }
func (r *RMAR) Store(b MAR)           { r.U32.Store(uint32(b)) }

type RMMAR struct{ mmio.UM32 }

func (rm RMMAR) Load() MAR   { return MAR(rm.UM32.Load()) }
func (rm RMMAR) Store(b MAR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) MA(n int) RMMAR {
	return RMMAR{mmio.UM32{&p.C[n].MAR.U32, uint32(MA)}}
}

type CSELR uint32

type RCSELR struct{ mmio.U32 }

func (r *RCSELR) LoadBits(mask CSELR) CSELR { return CSELR(r.U32.LoadBits(uint32(mask))) }
func (r *RCSELR) StoreBits(mask, b CSELR)   { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCSELR) SetBits(mask CSELR)        { r.U32.SetBits(uint32(mask)) }
func (r *RCSELR) ClearBits(mask CSELR)      { r.U32.ClearBits(uint32(mask)) }
func (r *RCSELR) Load() CSELR               { return CSELR(r.U32.Load()) }
func (r *RCSELR) Store(b CSELR)             { r.U32.Store(uint32(b)) }

type RMCSELR struct{ mmio.UM32 }

func (rm RMCSELR) Load() CSELR   { return CSELR(rm.UM32.Load()) }
func (rm RMCSELR) Store(b CSELR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) C1S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C1S)}}
}

func (p *Periph) C2S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C2S)}}
}

func (p *Periph) C3S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C3S)}}
}

func (p *Periph) C4S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C4S)}}
}

func (p *Periph) C5S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C5S)}}
}

func (p *Periph) C6S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C6S)}}
}

func (p *Periph) C7S() RMCSELR {
	return RMCSELR{mmio.UM32{&p.CSELR.U32, uint32(C7S)}}
}
