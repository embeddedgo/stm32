// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32f215

package spi

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	CR1     mmio.R32[CR1]
	CR2     mmio.R32[CR2]
	SR      mmio.R32[SR]
	DR      mmio.R32[uint32]
	CRCPR   mmio.R32[uint32]
	RXCRCR  mmio.R32[uint32]
	TXCRCR  mmio.R32[uint32]
	I2SCFGR mmio.R32[I2SCFGR]
	I2SPR   mmio.R32[I2SPR]
}

func SPI1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SPI1_BASE))) }
func SPI2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SPI2_BASE))) }
func SPI3() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SPI3_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	switch p.BaseAddr() {
	default:
		return bus.APB1
	case mmap.SPI1_BASE:
		return bus.APB2
	}
}

type CR1 uint32

func CPHA_(p *Periph) mmio.RM32[CR1]     { return mmio.RM32[CR1]{R: &p.CR1, Mask: CPHA} }
func CPOL_(p *Periph) mmio.RM32[CR1]     { return mmio.RM32[CR1]{R: &p.CR1, Mask: CPOL} }
func MSTR_(p *Periph) mmio.RM32[CR1]     { return mmio.RM32[CR1]{R: &p.CR1, Mask: MSTR} }
func BR_(p *Periph) mmio.RM32[CR1]       { return mmio.RM32[CR1]{R: &p.CR1, Mask: BR} }
func SPE_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: SPE} }
func LSBFIRST_(p *Periph) mmio.RM32[CR1] { return mmio.RM32[CR1]{R: &p.CR1, Mask: LSBFIRST} }
func SSI_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: SSI} }
func SSM_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: SSM} }
func RXONLY_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: RXONLY} }
func DFF_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: DFF} }
func CRCNEXT_(p *Periph) mmio.RM32[CR1]  { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRCNEXT} }
func CRCEN_(p *Periph) mmio.RM32[CR1]    { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRCEN} }
func BIDIOE_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: BIDIOE} }
func BIDIMODE_(p *Periph) mmio.RM32[CR1] { return mmio.RM32[CR1]{R: &p.CR1, Mask: BIDIMODE} }

type CR2 uint32

func RXDMAEN_(p *Periph) mmio.RM32[CR2] { return mmio.RM32[CR2]{R: &p.CR2, Mask: RXDMAEN} }
func TXDMAEN_(p *Periph) mmio.RM32[CR2] { return mmio.RM32[CR2]{R: &p.CR2, Mask: TXDMAEN} }
func SSOE_(p *Periph) mmio.RM32[CR2]    { return mmio.RM32[CR2]{R: &p.CR2, Mask: SSOE} }
func FRF_(p *Periph) mmio.RM32[CR2]     { return mmio.RM32[CR2]{R: &p.CR2, Mask: FRF} }
func ERRIE_(p *Periph) mmio.RM32[CR2]   { return mmio.RM32[CR2]{R: &p.CR2, Mask: ERRIE} }
func RXNEIE_(p *Periph) mmio.RM32[CR2]  { return mmio.RM32[CR2]{R: &p.CR2, Mask: RXNEIE} }
func TXEIE_(p *Periph) mmio.RM32[CR2]   { return mmio.RM32[CR2]{R: &p.CR2, Mask: TXEIE} }

type SR uint32

func RXNE_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: RXNE} }
func TXE_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: TXE} }
func CHSIDE_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: CHSIDE} }
func UDR_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: UDR} }
func CRCERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: CRCERR} }
func MODF_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: MODF} }
func OVR_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: OVR} }
func BSY_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: BSY} }
func TIFRFE_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: TIFRFE} }

type I2SCFGR uint32

func CHLEN_(p *Periph) mmio.RM32[I2SCFGR]   { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: CHLEN} }
func DATLEN_(p *Periph) mmio.RM32[I2SCFGR]  { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: DATLEN} }
func CKPOL_(p *Periph) mmio.RM32[I2SCFGR]   { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: CKPOL} }
func I2SSTD_(p *Periph) mmio.RM32[I2SCFGR]  { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: I2SSTD} }
func PCMSYNC_(p *Periph) mmio.RM32[I2SCFGR] { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: PCMSYNC} }
func I2SCFG_(p *Periph) mmio.RM32[I2SCFGR]  { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: I2SCFG} }
func I2SE_(p *Periph) mmio.RM32[I2SCFGR]    { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: I2SE} }
func I2SMOD_(p *Periph) mmio.RM32[I2SCFGR]  { return mmio.RM32[I2SCFGR]{R: &p.I2SCFGR, Mask: I2SMOD} }

type I2SPR uint32

func I2SDIV_(p *Periph) mmio.RM32[I2SPR] { return mmio.RM32[I2SPR]{R: &p.I2SPR, Mask: I2SDIV} }
func ODD_(p *Periph) mmio.RM32[I2SPR]    { return mmio.RM32[I2SPR]{R: &p.I2SPR, Mask: ODD} }
func MCKOE_(p *Periph) mmio.RM32[I2SPR]  { return mmio.RM32[I2SPR]{R: &p.I2SPR, Mask: MCKOE} }
