// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32l4x6

package spi

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	CR1    mmio.R32[CR1]
	CR2    mmio.R32[CR2]
	SR     mmio.R32[SR]
	DR     mmio.R32[uint32]
	CRCPR  mmio.R32[uint32]
	RXCRCR mmio.R32[uint32]
	TXCRCR mmio.R32[uint32]
}

func SPI1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SPI1_BASE))) }
func SPI2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SPI2_BASE))) }
func SPI3() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SPI3_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	switch p.BaseAddr() {
	default:
		return bus.APB1
	case mmap.SPI1_BASE:
		return bus.APB2
	}
}

type CR1 uint32

func CPHA_(p *Periph) mmio.RM32[CR1]     { return mmio.RM32[CR1]{R: &p.CR1, Mask: CPHA} }
func CPOL_(p *Periph) mmio.RM32[CR1]     { return mmio.RM32[CR1]{R: &p.CR1, Mask: CPOL} }
func MSTR_(p *Periph) mmio.RM32[CR1]     { return mmio.RM32[CR1]{R: &p.CR1, Mask: MSTR} }
func BR_(p *Periph) mmio.RM32[CR1]       { return mmio.RM32[CR1]{R: &p.CR1, Mask: BR} }
func SPE_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: SPE} }
func LSBFIRST_(p *Periph) mmio.RM32[CR1] { return mmio.RM32[CR1]{R: &p.CR1, Mask: LSBFIRST} }
func SSI_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: SSI} }
func SSM_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: SSM} }
func RXONLY_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: RXONLY} }
func DFF_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: DFF} }
func CRCNEXT_(p *Periph) mmio.RM32[CR1]  { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRCNEXT} }
func CRCEN_(p *Periph) mmio.RM32[CR1]    { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRCEN} }
func BIDIOE_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: BIDIOE} }
func BIDIMODE_(p *Periph) mmio.RM32[CR1] { return mmio.RM32[CR1]{R: &p.CR1, Mask: BIDIMODE} }

type CR2 uint32

func RXDMAEN_(p *Periph) mmio.RM32[CR2] { return mmio.RM32[CR2]{R: &p.CR2, Mask: RXDMAEN} }
func TXDMAEN_(p *Periph) mmio.RM32[CR2] { return mmio.RM32[CR2]{R: &p.CR2, Mask: TXDMAEN} }
func SSOE_(p *Periph) mmio.RM32[CR2]    { return mmio.RM32[CR2]{R: &p.CR2, Mask: SSOE} }
func NSSP_(p *Periph) mmio.RM32[CR2]    { return mmio.RM32[CR2]{R: &p.CR2, Mask: NSSP} }
func FRF_(p *Periph) mmio.RM32[CR2]     { return mmio.RM32[CR2]{R: &p.CR2, Mask: FRF} }
func ERRIE_(p *Periph) mmio.RM32[CR2]   { return mmio.RM32[CR2]{R: &p.CR2, Mask: ERRIE} }
func RXNEIE_(p *Periph) mmio.RM32[CR2]  { return mmio.RM32[CR2]{R: &p.CR2, Mask: RXNEIE} }
func TXEIE_(p *Periph) mmio.RM32[CR2]   { return mmio.RM32[CR2]{R: &p.CR2, Mask: TXEIE} }
func DS_(p *Periph) mmio.RM32[CR2]      { return mmio.RM32[CR2]{R: &p.CR2, Mask: DS} }
func FRXTH_(p *Periph) mmio.RM32[CR2]   { return mmio.RM32[CR2]{R: &p.CR2, Mask: FRXTH} }
func LDMA_RX_(p *Periph) mmio.RM32[CR2] { return mmio.RM32[CR2]{R: &p.CR2, Mask: LDMA_RX} }
func LDMA_TX_(p *Periph) mmio.RM32[CR2] { return mmio.RM32[CR2]{R: &p.CR2, Mask: LDMA_TX} }

type SR uint32

func RXNE_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: RXNE} }
func TXE_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: TXE} }
func CRCERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: CRCERR} }
func MODF_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: MODF} }
func OVR_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: OVR} }
func BSY_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: BSY} }
func TIFRFE_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: TIFRFE} }
func FRLVL_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: FRLVL} }
func FTLVL_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: FTLVL} }
