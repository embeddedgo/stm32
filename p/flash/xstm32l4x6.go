// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32l4x6

package flash

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ACR      mmio.R32[ACR]
	PDKEYR   mmio.R32[uint32]
	KEYR     mmio.R32[uint32]
	OPTKEYR  mmio.R32[uint32]
	SR       mmio.R32[SR]
	CR       mmio.R32[CR]
	ECCR     mmio.R32[ECCR]
	_        uint32
	OPTR     mmio.R32[OPTR]
	PCROP1SR mmio.R32[PCROP1SR]
	PCROP1ER mmio.R32[PCROP1ER]
	WRP1AR   mmio.R32[WRP1AR]
	WRP1BR   mmio.R32[WRP1BR]
	_        [4]uint32
	PCROP2SR mmio.R32[PCROP2SR]
	PCROP2ER mmio.R32[PCROP2ER]
	WRP2AR   mmio.R32[WRP2AR]
	WRP2BR   mmio.R32[WRP2BR]
}

func FLASH() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.FLASH_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	return bus.AHB1
}

type ACR uint32

func LATENCY_(p *Periph) mmio.RM32[ACR]  { return mmio.RM32[ACR]{R: &p.ACR, Mask: LATENCY} }
func PRFTEN_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{R: &p.ACR, Mask: PRFTEN} }
func ICEN_(p *Periph) mmio.RM32[ACR]     { return mmio.RM32[ACR]{R: &p.ACR, Mask: ICEN} }
func DCEN_(p *Periph) mmio.RM32[ACR]     { return mmio.RM32[ACR]{R: &p.ACR, Mask: DCEN} }
func ICRST_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: ICRST} }
func DCRST_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: DCRST} }
func RUN_PD_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{R: &p.ACR, Mask: RUN_PD} }
func SLEEP_PD_(p *Periph) mmio.RM32[ACR] { return mmio.RM32[ACR]{R: &p.ACR, Mask: SLEEP_PD} }

type SR uint32

func EOP_(p *Periph) mmio.RM32[SR]     { return mmio.RM32[SR]{R: &p.SR, Mask: EOP} }
func OPERR_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: OPERR} }
func PROGERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: PROGERR} }
func WRPERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: WRPERR} }
func PGAERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: PGAERR} }
func SIZERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: SIZERR} }
func PGSERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: PGSERR} }
func MISERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: MISERR} }
func FASTERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: FASTERR} }
func RDERR_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: RDERR} }
func OPTVERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: OPTVERR} }
func BSY_(p *Periph) mmio.RM32[SR]     { return mmio.RM32[SR]{R: &p.SR, Mask: BSY} }

type CR uint32

func PG_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{R: &p.CR, Mask: PG} }
func PER_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{R: &p.CR, Mask: PER} }
func MER1_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: MER1} }
func PNB_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{R: &p.CR, Mask: PNB} }
func BKER_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: BKER} }
func MER2_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: MER2} }
func START_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: START} }
func OPTSTRT_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: OPTSTRT} }
func FSTPG_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: FSTPG} }
func EOPIE_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: EOPIE} }
func ERRIE_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: ERRIE} }
func RDERRIE_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: RDERRIE} }
func OBL_LAUNCH_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: OBL_LAUNCH} }
func OPTLOCK_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: OPTLOCK} }
func LOCK_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: LOCK} }

type ECCR uint32

func ADDR_ECC_(p *Periph) mmio.RM32[ECCR] { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ADDR_ECC} }
func BK_ECC_(p *Periph) mmio.RM32[ECCR]   { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: BK_ECC} }
func SYSF_ECC_(p *Periph) mmio.RM32[ECCR] { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: SYSF_ECC} }
func ECCIE_(p *Periph) mmio.RM32[ECCR]    { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCIE} }
func ECCC_(p *Periph) mmio.RM32[ECCR]     { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCC} }
func ECCD_(p *Periph) mmio.RM32[ECCR]     { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCD} }

type OPTR uint32

func RDP_(p *Periph) mmio.RM32[OPTR]        { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: RDP} }
func BOR_LEV_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: BOR_LEV} }
func nRST_STOP_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nRST_STOP} }
func nRST_STDBY_(p *Periph) mmio.RM32[OPTR] { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nRST_STDBY} }
func IDWG_SW_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IDWG_SW} }
func IWDG_STOP_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IWDG_STOP} }
func IWDG_STDBY_(p *Periph) mmio.RM32[OPTR] { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IWDG_STDBY} }
func WWDG_SW_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: WWDG_SW} }
func BFB2_(p *Periph) mmio.RM32[OPTR]       { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: BFB2} }
func DUALBANK_(p *Periph) mmio.RM32[OPTR]   { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: DUALBANK} }
func nBOOT1_(p *Periph) mmio.RM32[OPTR]     { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nBOOT1} }
func SRAM2_PE_(p *Periph) mmio.RM32[OPTR]   { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: SRAM2_PE} }
func SRAM2_RST_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: SRAM2_RST} }

type PCROP1SR uint32

func PCROP1_STRT_(p *Periph) mmio.RM32[PCROP1SR] {
	return mmio.RM32[PCROP1SR]{R: &p.PCROP1SR, Mask: PCROP1_STRT}
}

type PCROP1ER uint32

func PCROP1_END_(p *Periph) mmio.RM32[PCROP1ER] {
	return mmio.RM32[PCROP1ER]{R: &p.PCROP1ER, Mask: PCROP1_END}
}
func PCROP_RDP_(p *Periph) mmio.RM32[PCROP1ER] {
	return mmio.RM32[PCROP1ER]{R: &p.PCROP1ER, Mask: PCROP_RDP}
}

type WRP1AR uint32

func WRP1A_STRT_(p *Periph) mmio.RM32[WRP1AR] {
	return mmio.RM32[WRP1AR]{R: &p.WRP1AR, Mask: WRP1A_STRT}
}
func WRP1A_END_(p *Periph) mmio.RM32[WRP1AR] { return mmio.RM32[WRP1AR]{R: &p.WRP1AR, Mask: WRP1A_END} }

type WRP1BR uint32

func WRP1B_END_(p *Periph) mmio.RM32[WRP1BR] { return mmio.RM32[WRP1BR]{R: &p.WRP1BR, Mask: WRP1B_END} }
func WRP1B_STRT_(p *Periph) mmio.RM32[WRP1BR] {
	return mmio.RM32[WRP1BR]{R: &p.WRP1BR, Mask: WRP1B_STRT}
}

type PCROP2SR uint32

func PCROP2_STRT_(p *Periph) mmio.RM32[PCROP2SR] {
	return mmio.RM32[PCROP2SR]{R: &p.PCROP2SR, Mask: PCROP2_STRT}
}

type PCROP2ER uint32

func PCROP2_END_(p *Periph) mmio.RM32[PCROP2ER] {
	return mmio.RM32[PCROP2ER]{R: &p.PCROP2ER, Mask: PCROP2_END}
}

type WRP2AR uint32

func WRP2A_STRT_(p *Periph) mmio.RM32[WRP2AR] {
	return mmio.RM32[WRP2AR]{R: &p.WRP2AR, Mask: WRP2A_STRT}
}
func WRP2A_END_(p *Periph) mmio.RM32[WRP2AR] { return mmio.RM32[WRP2AR]{R: &p.WRP2AR, Mask: WRP2A_END} }

type WRP2BR uint32

func WRP2B_STRT_(p *Periph) mmio.RM32[WRP2BR] {
	return mmio.RM32[WRP2BR]{R: &p.WRP2BR, Mask: WRP2B_STRT}
}
func WRP2B_END_(p *Periph) mmio.RM32[WRP2BR] { return mmio.RM32[WRP2BR]{R: &p.WRP2BR, Mask: WRP2B_END} }
