// DO NOT EDIT THIS FILE. GENERATED BY xgen.

//go:build stm32l4x6

package flash

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ACR      mmio.R32[ACR]
	PDKEYR   mmio.R32[uint32]
	KEYR     mmio.R32[uint32]
	OPTKEYR  mmio.R32[uint32]
	SR       mmio.R32[SR]
	CR       mmio.R32[CR]
	ECCR     mmio.R32[ECCR]
	_        uint32
	OPTR     mmio.R32[OPTR]
	PCROP1SR mmio.R32[PCROP1SR]
	PCROP1ER mmio.R32[PCROP1ER]
	WRP1AR   mmio.R32[WRP1AR]
	WRP1BR   mmio.R32[WRP1BR]
	_        [4]uint32
	PCROP2SR mmio.R32[PCROP2SR]
	PCROP2ER mmio.R32[PCROP2ER]
	WRP2AR   mmio.R32[WRP2AR]
	WRP2BR   mmio.R32[WRP2BR]
}

func FLASH() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.FLASH_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	return bus.AHB1
}

type ACR uint32

func LATENCY_(p *Periph) mmio.RM32[ACR]  { return mmio.RM32[ACR]{&p.ACR, LATENCY} }
func PRFTEN_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{&p.ACR, PRFTEN} }
func ICEN_(p *Periph) mmio.RM32[ACR]     { return mmio.RM32[ACR]{&p.ACR, ICEN} }
func DCEN_(p *Periph) mmio.RM32[ACR]     { return mmio.RM32[ACR]{&p.ACR, DCEN} }
func ICRST_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{&p.ACR, ICRST} }
func DCRST_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{&p.ACR, DCRST} }
func RUN_PD_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{&p.ACR, RUN_PD} }
func SLEEP_PD_(p *Periph) mmio.RM32[ACR] { return mmio.RM32[ACR]{&p.ACR, SLEEP_PD} }

type SR uint32

func EOP_(p *Periph) mmio.RM32[SR]     { return mmio.RM32[SR]{&p.SR, EOP} }
func OPERR_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{&p.SR, OPERR} }
func PROGERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{&p.SR, PROGERR} }
func WRPERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, WRPERR} }
func PGAERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, PGAERR} }
func SIZERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, SIZERR} }
func PGSERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, PGSERR} }
func MISERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, MISERR} }
func FASTERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{&p.SR, FASTERR} }
func RDERR_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{&p.SR, RDERR} }
func OPTVERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{&p.SR, OPTVERR} }
func BSY_(p *Periph) mmio.RM32[SR]     { return mmio.RM32[SR]{&p.SR, BSY} }

type CR uint32

func PG_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, PG} }
func PER_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, PER} }
func MER1_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{&p.CR, MER1} }
func PNB_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, PNB} }
func BKER_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{&p.CR, BKER} }
func MER2_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{&p.CR, MER2} }
func START_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{&p.CR, START} }
func OPTSTRT_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{&p.CR, OPTSTRT} }
func FSTPG_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{&p.CR, FSTPG} }
func EOPIE_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{&p.CR, EOPIE} }
func ERRIE_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{&p.CR, ERRIE} }
func RDERRIE_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{&p.CR, RDERRIE} }
func OBL_LAUNCH_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{&p.CR, OBL_LAUNCH} }
func OPTLOCK_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{&p.CR, OPTLOCK} }
func LOCK_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{&p.CR, LOCK} }

type ECCR uint32

func ADDR_ECC_(p *Periph) mmio.RM32[ECCR] { return mmio.RM32[ECCR]{&p.ECCR, ADDR_ECC} }
func BK_ECC_(p *Periph) mmio.RM32[ECCR]   { return mmio.RM32[ECCR]{&p.ECCR, BK_ECC} }
func SYSF_ECC_(p *Periph) mmio.RM32[ECCR] { return mmio.RM32[ECCR]{&p.ECCR, SYSF_ECC} }
func ECCIE_(p *Periph) mmio.RM32[ECCR]    { return mmio.RM32[ECCR]{&p.ECCR, ECCIE} }
func ECCC_(p *Periph) mmio.RM32[ECCR]     { return mmio.RM32[ECCR]{&p.ECCR, ECCC} }
func ECCD_(p *Periph) mmio.RM32[ECCR]     { return mmio.RM32[ECCR]{&p.ECCR, ECCD} }

type OPTR uint32

func RDP_(p *Periph) mmio.RM32[OPTR]        { return mmio.RM32[OPTR]{&p.OPTR, RDP} }
func BOR_LEV_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{&p.OPTR, BOR_LEV} }
func nRST_STOP_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{&p.OPTR, nRST_STOP} }
func nRST_STDBY_(p *Periph) mmio.RM32[OPTR] { return mmio.RM32[OPTR]{&p.OPTR, nRST_STDBY} }
func IDWG_SW_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{&p.OPTR, IDWG_SW} }
func IWDG_STOP_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{&p.OPTR, IWDG_STOP} }
func IWDG_STDBY_(p *Periph) mmio.RM32[OPTR] { return mmio.RM32[OPTR]{&p.OPTR, IWDG_STDBY} }
func WWDG_SW_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{&p.OPTR, WWDG_SW} }
func BFB2_(p *Periph) mmio.RM32[OPTR]       { return mmio.RM32[OPTR]{&p.OPTR, BFB2} }
func DUALBANK_(p *Periph) mmio.RM32[OPTR]   { return mmio.RM32[OPTR]{&p.OPTR, DUALBANK} }
func nBOOT1_(p *Periph) mmio.RM32[OPTR]     { return mmio.RM32[OPTR]{&p.OPTR, nBOOT1} }
func SRAM2_PE_(p *Periph) mmio.RM32[OPTR]   { return mmio.RM32[OPTR]{&p.OPTR, SRAM2_PE} }
func SRAM2_RST_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{&p.OPTR, SRAM2_RST} }

type PCROP1SR uint32

func PCROP1_STRT_(p *Periph) mmio.RM32[PCROP1SR] {
	return mmio.RM32[PCROP1SR]{&p.PCROP1SR, PCROP1_STRT}
}

type PCROP1ER uint32

func PCROP1_END_(p *Periph) mmio.RM32[PCROP1ER] { return mmio.RM32[PCROP1ER]{&p.PCROP1ER, PCROP1_END} }
func PCROP_RDP_(p *Periph) mmio.RM32[PCROP1ER]  { return mmio.RM32[PCROP1ER]{&p.PCROP1ER, PCROP_RDP} }

type WRP1AR uint32

func WRP1A_STRT_(p *Periph) mmio.RM32[WRP1AR] { return mmio.RM32[WRP1AR]{&p.WRP1AR, WRP1A_STRT} }
func WRP1A_END_(p *Periph) mmio.RM32[WRP1AR]  { return mmio.RM32[WRP1AR]{&p.WRP1AR, WRP1A_END} }

type WRP1BR uint32

func WRP1B_END_(p *Periph) mmio.RM32[WRP1BR]  { return mmio.RM32[WRP1BR]{&p.WRP1BR, WRP1B_END} }
func WRP1B_STRT_(p *Periph) mmio.RM32[WRP1BR] { return mmio.RM32[WRP1BR]{&p.WRP1BR, WRP1B_STRT} }

type PCROP2SR uint32

func PCROP2_STRT_(p *Periph) mmio.RM32[PCROP2SR] {
	return mmio.RM32[PCROP2SR]{&p.PCROP2SR, PCROP2_STRT}
}

type PCROP2ER uint32

func PCROP2_END_(p *Periph) mmio.RM32[PCROP2ER] { return mmio.RM32[PCROP2ER]{&p.PCROP2ER, PCROP2_END} }

type WRP2AR uint32

func WRP2A_STRT_(p *Periph) mmio.RM32[WRP2AR] { return mmio.RM32[WRP2AR]{&p.WRP2AR, WRP2A_STRT} }
func WRP2A_END_(p *Periph) mmio.RM32[WRP2AR]  { return mmio.RM32[WRP2AR]{&p.WRP2AR, WRP2A_END} }

type WRP2BR uint32

func WRP2B_STRT_(p *Periph) mmio.RM32[WRP2BR] { return mmio.RM32[WRP2BR]{&p.WRP2BR, WRP2B_STRT} }
func WRP2B_END_(p *Periph) mmio.RM32[WRP2BR]  { return mmio.RM32[WRP2BR]{&p.WRP2BR, WRP2B_END} }
