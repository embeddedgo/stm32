// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32f407

package flash

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ACR     mmio.R32[ACR]
	KEYR    mmio.R32[uint32]
	OPTKEYR mmio.R32[uint32]
	SR      mmio.R32[SR]
	CR      mmio.R32[CR]
	OPTCR   mmio.R32[OPTCR]
}

func FLASH() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.FLASH_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type ACR uint32

func LATENCY_(p *Periph) mmio.RM32[ACR] { return mmio.RM32[ACR]{R: &p.ACR, Mask: LATENCY} }
func PRFTEN_(p *Periph) mmio.RM32[ACR]  { return mmio.RM32[ACR]{R: &p.ACR, Mask: PRFTEN} }
func ICEN_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: ICEN} }
func DCEN_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: DCEN} }
func ICRST_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{R: &p.ACR, Mask: ICRST} }
func DCRST_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{R: &p.ACR, Mask: DCRST} }

type SR uint32

func EOP_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: EOP} }
func OPERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: OPERR} }
func WRPERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: WRPERR} }
func PGAERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: PGAERR} }
func PGPERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: PGPERR} }
func PGSERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: PGSERR} }
func BSY_(p *Periph) mmio.RM32[SR]    { return mmio.RM32[SR]{R: &p.SR, Mask: BSY} }

type CR uint32

func PG_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: PG} }
func SER_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: SER} }
func MER_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: MER} }
func SNB_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: SNB} }
func PSIZE_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: PSIZE} }
func STRT_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: STRT} }
func EOPIE_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: EOPIE} }
func ERRIE_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: ERRIE} }
func LOCK_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: LOCK} }

type OPTCR uint32

func OPTLOCK_(p *Periph) mmio.RM32[OPTCR]    { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: OPTLOCK} }
func OPTSTRT_(p *Periph) mmio.RM32[OPTCR]    { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: OPTSTRT} }
func BOR_LEV_(p *Periph) mmio.RM32[OPTCR]    { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: BOR_LEV} }
func WDG_SW_(p *Periph) mmio.RM32[OPTCR]     { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: WDG_SW} }
func nRST_STOP_(p *Periph) mmio.RM32[OPTCR]  { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: nRST_STOP} }
func nRST_STDBY_(p *Periph) mmio.RM32[OPTCR] { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: nRST_STDBY} }
func RDP_(p *Periph) mmio.RM32[OPTCR]        { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: RDP} }
func nWRP_(p *Periph) mmio.RM32[OPTCR]       { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: nWRP} }
