// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32h7x3

package flash

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ACR        mmio.R32[ACR]
	KEYR1      mmio.R32[uint32]
	OPTKEYR    mmio.R32[uint32]
	CR1        mmio.R32[CR1]
	SR1        mmio.R32[SR1]
	CCR1       mmio.R32[CCR1]
	OPTCR      mmio.R32[OPTCR]
	OPTSR_CUR  mmio.R32[OPTSR]
	OPTSR_PRG  mmio.R32[OPTSR]
	OPTCCR     mmio.R32[OPTCCR]
	PRAR_CUR1  mmio.R32[PRAR]
	PRAR_PRG1  mmio.R32[PRAR]
	SCAR_CUR1  mmio.R32[SCAR]
	SCAR_PRG1  mmio.R32[SCAR]
	WPSN_CUR1R mmio.R32[WPSN]
	WPSN_PRG1R mmio.R32[WPSN]
	BOOT_CURR  mmio.R32[BOOT]
	BOOT_PRGR  mmio.R32[BOOT]
	_          [2]uint32
	CRCCR1     mmio.R32[CRCCR1]
	CRCSADD1R  mmio.R32[CRCSADD1R]
	CRCEADD1R  mmio.R32[CRCEADD1R]
	CRCDATAR   mmio.R32[CRCDATAR]
	ECC_FA1R   mmio.R32[ECC_FA1R]
}

func FLASH1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.Flash_BASE))) }
func FLASH2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.Flash_BASE + 0x100))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type ACR uint32

func LATENCY_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: LATENCY} }
func WRHIGHFREQ_(p *Periph) mmio.RM32[ACR] { return mmio.RM32[ACR]{R: &p.ACR, Mask: WRHIGHFREQ} }

type CR1 uint32

func LOCK1_(p *Periph) mmio.RM32[CR1]       { return mmio.RM32[CR1]{R: &p.CR1, Mask: LOCK1} }
func PG1_(p *Periph) mmio.RM32[CR1]         { return mmio.RM32[CR1]{R: &p.CR1, Mask: PG1} }
func SER1_(p *Periph) mmio.RM32[CR1]        { return mmio.RM32[CR1]{R: &p.CR1, Mask: SER1} }
func BER1_(p *Periph) mmio.RM32[CR1]        { return mmio.RM32[CR1]{R: &p.CR1, Mask: BER1} }
func PSIZE1_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: PSIZE1} }
func FW1_(p *Periph) mmio.RM32[CR1]         { return mmio.RM32[CR1]{R: &p.CR1, Mask: FW1} }
func START1_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: START1} }
func SNB1_(p *Periph) mmio.RM32[CR1]        { return mmio.RM32[CR1]{R: &p.CR1, Mask: SNB1} }
func CRC_EN_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRC_EN} }
func EOPIE1_(p *Periph) mmio.RM32[CR1]      { return mmio.RM32[CR1]{R: &p.CR1, Mask: EOPIE1} }
func WRPERRIE1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: WRPERRIE1} }
func PGSERRIE1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: PGSERRIE1} }
func STRBERRIE1_(p *Periph) mmio.RM32[CR1]  { return mmio.RM32[CR1]{R: &p.CR1, Mask: STRBERRIE1} }
func INCERRIE1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: INCERRIE1} }
func OPERRIE1_(p *Periph) mmio.RM32[CR1]    { return mmio.RM32[CR1]{R: &p.CR1, Mask: OPERRIE1} }
func RDPERRIE1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: RDPERRIE1} }
func RDSERRIE1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: RDSERRIE1} }
func SNECCERR1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: SNECCERR1} }
func DBECCERRIE1_(p *Periph) mmio.RM32[CR1] { return mmio.RM32[CR1]{R: &p.CR1, Mask: DBECCERRIE1} }
func CRCENDIE1_(p *Periph) mmio.RM32[CR1]   { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRCENDIE1} }
func CRCRDERRIE1_(p *Periph) mmio.RM32[CR1] { return mmio.RM32[CR1]{R: &p.CR1, Mask: CRCRDERRIE1} }

type SR1 uint32

func BSY1_(p *Periph) mmio.RM32[SR1]      { return mmio.RM32[SR1]{R: &p.SR1, Mask: BSY1} }
func WBNE1_(p *Periph) mmio.RM32[SR1]     { return mmio.RM32[SR1]{R: &p.SR1, Mask: WBNE1} }
func QW1_(p *Periph) mmio.RM32[SR1]       { return mmio.RM32[SR1]{R: &p.SR1, Mask: QW1} }
func CRC_BUSY1_(p *Periph) mmio.RM32[SR1] { return mmio.RM32[SR1]{R: &p.SR1, Mask: CRC_BUSY1} }
func EOP1_(p *Periph) mmio.RM32[SR1]      { return mmio.RM32[SR1]{R: &p.SR1, Mask: EOP1} }
func WRPERR1_(p *Periph) mmio.RM32[SR1]   { return mmio.RM32[SR1]{R: &p.SR1, Mask: WRPERR1} }
func PGSERR1_(p *Periph) mmio.RM32[SR1]   { return mmio.RM32[SR1]{R: &p.SR1, Mask: PGSERR1} }
func STRBERR1_(p *Periph) mmio.RM32[SR1]  { return mmio.RM32[SR1]{R: &p.SR1, Mask: STRBERR1} }
func INCERR1_(p *Periph) mmio.RM32[SR1]   { return mmio.RM32[SR1]{R: &p.SR1, Mask: INCERR1} }
func OPERR1_(p *Periph) mmio.RM32[SR1]    { return mmio.RM32[SR1]{R: &p.SR1, Mask: OPERR1} }
func RDPERR1_(p *Periph) mmio.RM32[SR1]   { return mmio.RM32[SR1]{R: &p.SR1, Mask: RDPERR1} }
func RDSERR1_(p *Periph) mmio.RM32[SR1]   { return mmio.RM32[SR1]{R: &p.SR1, Mask: RDSERR1} }
func SNECCERR_(p *Periph) mmio.RM32[SR1]  { return mmio.RM32[SR1]{R: &p.SR1, Mask: SNECCERR} }
func DBECCERR1_(p *Periph) mmio.RM32[SR1] { return mmio.RM32[SR1]{R: &p.SR1, Mask: DBECCERR1} }
func CRCEND1_(p *Periph) mmio.RM32[SR1]   { return mmio.RM32[SR1]{R: &p.SR1, Mask: CRCEND1} }
func CRCRDERR1_(p *Periph) mmio.RM32[SR1] { return mmio.RM32[SR1]{R: &p.SR1, Mask: CRCRDERR1} }

type CCR1 uint32

func CLR_EOP1_(p *Periph) mmio.RM32[CCR1]     { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_EOP1} }
func CLR_WRPERR1_(p *Periph) mmio.RM32[CCR1]  { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_WRPERR1} }
func CLR_PGSERR1_(p *Periph) mmio.RM32[CCR1]  { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_PGSERR1} }
func CLR_STRBERR1_(p *Periph) mmio.RM32[CCR1] { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_STRBERR1} }
func CLR_INCERR1_(p *Periph) mmio.RM32[CCR1]  { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_INCERR1} }
func CLR_OPERR1_(p *Periph) mmio.RM32[CCR1]   { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_OPERR1} }
func CLR_RDPERR1_(p *Periph) mmio.RM32[CCR1]  { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_RDPERR1} }
func CLR_RDSERR1_(p *Periph) mmio.RM32[CCR1]  { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_RDSERR1} }
func CLR_SNECCERR1_(p *Periph) mmio.RM32[CCR1] {
	return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_SNECCERR1}
}
func CLR_DBECCERR1_(p *Periph) mmio.RM32[CCR1] {
	return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_DBECCERR1}
}
func CLR_CRCEND1_(p *Periph) mmio.RM32[CCR1] { return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_CRCEND1} }
func CLR_CRCRDERR1_(p *Periph) mmio.RM32[CCR1] {
	return mmio.RM32[CCR1]{R: &p.CCR1, Mask: CLR_CRCRDERR1}
}

type OPTCR uint32

func OPTLOCK_(p *Periph) mmio.RM32[OPTCR]  { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: OPTLOCK} }
func OPTSTART_(p *Periph) mmio.RM32[OPTCR] { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: OPTSTART} }
func MER_(p *Periph) mmio.RM32[OPTCR]      { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: MER} }
func OPTCHANGEERRIE_(p *Periph) mmio.RM32[OPTCR] {
	return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: OPTCHANGEERRIE}
}
func SWAP_BANK_(p *Periph) mmio.RM32[OPTCR] { return mmio.RM32[OPTCR]{R: &p.OPTCR, Mask: SWAP_BANK} }

type OPTSR uint32

type OPTCCR uint32

func CLR_OPTCHANGEERR_(p *Periph) mmio.RM32[OPTCCR] {
	return mmio.RM32[OPTCCR]{R: &p.OPTCCR, Mask: CLR_OPTCHANGEERR}
}

type PRAR uint32

type SCAR uint32

type WPSN uint32

type BOOT uint32

type CRCCR1 uint32

func CRC_SECT_(p *Periph) mmio.RM32[CRCCR1] { return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: CRC_SECT} }
func ALL_BANK_(p *Periph) mmio.RM32[CRCCR1] { return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: ALL_BANK} }
func CRC_BY_SECT_(p *Periph) mmio.RM32[CRCCR1] {
	return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: CRC_BY_SECT}
}
func ADD_SECT_(p *Periph) mmio.RM32[CRCCR1] { return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: ADD_SECT} }
func CLEAN_SECT_(p *Periph) mmio.RM32[CRCCR1] {
	return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: CLEAN_SECT}
}
func START_CRC_(p *Periph) mmio.RM32[CRCCR1] { return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: START_CRC} }
func CLEAN_CRC_(p *Periph) mmio.RM32[CRCCR1] { return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: CLEAN_CRC} }
func CRC_BURST_(p *Periph) mmio.RM32[CRCCR1] { return mmio.RM32[CRCCR1]{R: &p.CRCCR1, Mask: CRC_BURST} }

type CRCSADD1R uint32

func CRC_START_ADDR_(p *Periph) mmio.RM32[CRCSADD1R] {
	return mmio.RM32[CRCSADD1R]{R: &p.CRCSADD1R, Mask: CRC_START_ADDR}
}

type CRCEADD1R uint32

func CRC_END_ADDR_(p *Periph) mmio.RM32[CRCEADD1R] {
	return mmio.RM32[CRCEADD1R]{R: &p.CRCEADD1R, Mask: CRC_END_ADDR}
}

type CRCDATAR uint32

func CRC_DATA_(p *Periph) mmio.RM32[CRCDATAR] {
	return mmio.RM32[CRCDATAR]{R: &p.CRCDATAR, Mask: CRC_DATA}
}

type ECC_FA1R uint32

func FAIL_ECC_ADDR1_(p *Periph) mmio.RM32[ECC_FA1R] {
	return mmio.RM32[ECC_FA1R]{R: &p.ECC_FA1R, Mask: FAIL_ECC_ADDR1}
}
