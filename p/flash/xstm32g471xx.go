// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32g471xx

package flash

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ACR      mmio.R32[ACR]
	PDKEYR   mmio.R32[uint32]
	KEYR     mmio.R32[uint32]
	OPTKEYR  mmio.R32[uint32]
	SR       mmio.R32[SR]
	CR       mmio.R32[CR]
	ECCR     mmio.R32[ECCR]
	_        uint32
	OPTR     mmio.R32[OPTR]
	PCROP1SR mmio.R32[PCROP1SR]
	PCROP1ER mmio.R32[PCROP1ER]
	WRP1AR   mmio.R32[WRP1AR]
	WRP1BR   mmio.R32[WRP1BR]
	_        [15]uint32
	SEC1R    mmio.R32[SEC1R]
}

func FLASH() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.FLASH_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type ACR uint32

func LATENCY_(p *Periph) mmio.RM32[ACR]  { return mmio.RM32[ACR]{R: &p.ACR, Mask: LATENCY} }
func PRFTEN_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{R: &p.ACR, Mask: PRFTEN} }
func ICEN_(p *Periph) mmio.RM32[ACR]     { return mmio.RM32[ACR]{R: &p.ACR, Mask: ICEN} }
func DCEN_(p *Periph) mmio.RM32[ACR]     { return mmio.RM32[ACR]{R: &p.ACR, Mask: DCEN} }
func ICRST_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: ICRST} }
func DCRST_(p *Periph) mmio.RM32[ACR]    { return mmio.RM32[ACR]{R: &p.ACR, Mask: DCRST} }
func RUN_PD_(p *Periph) mmio.RM32[ACR]   { return mmio.RM32[ACR]{R: &p.ACR, Mask: RUN_PD} }
func SLEEP_PD_(p *Periph) mmio.RM32[ACR] { return mmio.RM32[ACR]{R: &p.ACR, Mask: SLEEP_PD} }
func DBG_SWEN_(p *Periph) mmio.RM32[ACR] { return mmio.RM32[ACR]{R: &p.ACR, Mask: DBG_SWEN} }

type SR uint32

func EOP_(p *Periph) mmio.RM32[SR]     { return mmio.RM32[SR]{R: &p.SR, Mask: EOP} }
func OPERR_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: OPERR} }
func PROGERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: PROGERR} }
func WRPERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: WRPERR} }
func PGAERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: PGAERR} }
func SIZERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: SIZERR} }
func PGSERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: PGSERR} }
func MISERR_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{R: &p.SR, Mask: MISERR} }
func FASTERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: FASTERR} }
func RDERR_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{R: &p.SR, Mask: RDERR} }
func OPTVERR_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{R: &p.SR, Mask: OPTVERR} }
func BSY_(p *Periph) mmio.RM32[SR]     { return mmio.RM32[SR]{R: &p.SR, Mask: BSY} }

type CR uint32

func PG_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{R: &p.CR, Mask: PG} }
func PER_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{R: &p.CR, Mask: PER} }
func MER1_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: MER1} }
func PNB_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{R: &p.CR, Mask: PNB} }
func STRT_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: STRT} }
func OPTSTRT_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: OPTSTRT} }
func FSTPG_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: FSTPG} }
func EOPIE_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: EOPIE} }
func ERRIE_(p *Periph) mmio.RM32[CR]      { return mmio.RM32[CR]{R: &p.CR, Mask: ERRIE} }
func RDERRIE_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: RDERRIE} }
func OBL_LAUNCH_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: OBL_LAUNCH} }
func SEC_PROT1_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: SEC_PROT1} }
func OPTLOCK_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: OPTLOCK} }
func LOCK_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{R: &p.CR, Mask: LOCK} }

type ECCR uint32

func ADDR_ECC_(p *Periph) mmio.RM32[ECCR] { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ADDR_ECC} }
func BK_ECC_(p *Periph) mmio.RM32[ECCR]   { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: BK_ECC} }
func SYSF_ECC_(p *Periph) mmio.RM32[ECCR] { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: SYSF_ECC} }
func ECCIE_(p *Periph) mmio.RM32[ECCR]    { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCIE} }
func ECCC2_(p *Periph) mmio.RM32[ECCR]    { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCC2} }
func ECCD2_(p *Periph) mmio.RM32[ECCR]    { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCD2} }
func ECCC_(p *Periph) mmio.RM32[ECCR]     { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCC} }
func ECCD_(p *Periph) mmio.RM32[ECCR]     { return mmio.RM32[ECCR]{R: &p.ECCR, Mask: ECCD} }

type OPTR uint32

func RDP_(p *Periph) mmio.RM32[OPTR]        { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: RDP} }
func BOR_LEV_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: BOR_LEV} }
func nRST_STOP_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nRST_STOP} }
func nRST_STDBY_(p *Periph) mmio.RM32[OPTR] { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nRST_STDBY} }
func nRST_SHDW_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nRST_SHDW} }
func IDWG_SW_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IDWG_SW} }
func IWDG_STOP_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IWDG_STOP} }
func IWDG_STDBY_(p *Periph) mmio.RM32[OPTR] { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IWDG_STDBY} }
func WWDG_SW_(p *Periph) mmio.RM32[OPTR]    { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: WWDG_SW} }
func nBOOT1_(p *Periph) mmio.RM32[OPTR]     { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nBOOT1} }
func SRAM2_PE_(p *Periph) mmio.RM32[OPTR]   { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: SRAM2_PE} }
func SRAM2_RST_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: SRAM2_RST} }
func nSWBOOT0_(p *Periph) mmio.RM32[OPTR]   { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nSWBOOT0} }
func nBOOT0_(p *Periph) mmio.RM32[OPTR]     { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: nBOOT0} }
func NRST_MODE_(p *Periph) mmio.RM32[OPTR]  { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: NRST_MODE} }
func IRHEN_(p *Periph) mmio.RM32[OPTR]      { return mmio.RM32[OPTR]{R: &p.OPTR, Mask: IRHEN} }

type PCROP1SR uint32

func PCROP1_STRT_(p *Periph) mmio.RM32[PCROP1SR] {
	return mmio.RM32[PCROP1SR]{R: &p.PCROP1SR, Mask: PCROP1_STRT}
}

type PCROP1ER uint32

func PCROP1_END_(p *Periph) mmio.RM32[PCROP1ER] {
	return mmio.RM32[PCROP1ER]{R: &p.PCROP1ER, Mask: PCROP1_END}
}
func PCROP_RDP_(p *Periph) mmio.RM32[PCROP1ER] {
	return mmio.RM32[PCROP1ER]{R: &p.PCROP1ER, Mask: PCROP_RDP}
}

type WRP1AR uint32

func WRP1A_STRT_(p *Periph) mmio.RM32[WRP1AR] {
	return mmio.RM32[WRP1AR]{R: &p.WRP1AR, Mask: WRP1A_STRT}
}
func WRP1A_END_(p *Periph) mmio.RM32[WRP1AR] { return mmio.RM32[WRP1AR]{R: &p.WRP1AR, Mask: WRP1A_END} }

type WRP1BR uint32

func WRP1B_STRT_(p *Periph) mmio.RM32[WRP1BR] {
	return mmio.RM32[WRP1BR]{R: &p.WRP1BR, Mask: WRP1B_STRT}
}
func WRP1B_END_(p *Periph) mmio.RM32[WRP1BR] { return mmio.RM32[WRP1BR]{R: &p.WRP1BR, Mask: WRP1B_END} }

type SEC1R uint32

func SEC_SIZE1_(p *Periph) mmio.RM32[SEC1R] { return mmio.RM32[SEC1R]{R: &p.SEC1R, Mask: SEC_SIZE1} }
func BOOT_LOCK_(p *Periph) mmio.RM32[SEC1R] { return mmio.RM32[SEC1R]{R: &p.SEC1R, Mask: BOOT_LOCK} }
