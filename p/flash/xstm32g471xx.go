// DO NOT EDIT THIS FILE. GENERATED BY xgen.

// +build stm32g471xx

package flash

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	ACR      RACR
	PDKEYR   RPDKEYR
	KEYR     RKEYR
	OPTKEYR  ROPTKEYR
	SR       RSR
	CR       RCR
	ECCR     RECCR
	_        uint32
	OPTR     ROPTR
	PCROP1SR RPCROP1SR
	PCROP1ER RPCROP1ER
	WRP1AR   RWRP1AR
	WRP1BR   RWRP1BR
	_        [15]uint32
	SEC1R    RSEC1R
}

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func FLASH() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.FLASH_BASE))) }

type ACR uint32

type RACR struct{ mmio.U32 }

func (r *RACR) LoadBits(mask ACR) ACR { return ACR(r.U32.LoadBits(uint32(mask))) }
func (r *RACR) StoreBits(mask, b ACR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RACR) SetBits(mask ACR)      { r.U32.SetBits(uint32(mask)) }
func (r *RACR) ClearBits(mask ACR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RACR) Load() ACR             { return ACR(r.U32.Load()) }
func (r *RACR) Store(b ACR)           { r.U32.Store(uint32(b)) }

type RMACR struct{ mmio.UM32 }

func (rm RMACR) Load() ACR   { return ACR(rm.UM32.Load()) }
func (rm RMACR) Store(b ACR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) LATENCY() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(LATENCY)}}
}

func (p *Periph) PRFTEN() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(PRFTEN)}}
}

func (p *Periph) ICEN() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(ICEN)}}
}

func (p *Periph) DCEN() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(DCEN)}}
}

func (p *Periph) ICRST() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(ICRST)}}
}

func (p *Periph) DCRST() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(DCRST)}}
}

func (p *Periph) RUN_PD() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(RUN_PD)}}
}

func (p *Periph) SLEEP_PD() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(SLEEP_PD)}}
}

func (p *Periph) DBG_SWEN() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(DBG_SWEN)}}
}

type PDKEYR uint32

type RPDKEYR struct{ mmio.U32 }

func (r *RPDKEYR) LoadBits(mask PDKEYR) PDKEYR { return PDKEYR(r.U32.LoadBits(uint32(mask))) }
func (r *RPDKEYR) StoreBits(mask, b PDKEYR)    { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPDKEYR) SetBits(mask PDKEYR)         { r.U32.SetBits(uint32(mask)) }
func (r *RPDKEYR) ClearBits(mask PDKEYR)       { r.U32.ClearBits(uint32(mask)) }
func (r *RPDKEYR) Load() PDKEYR                { return PDKEYR(r.U32.Load()) }
func (r *RPDKEYR) Store(b PDKEYR)              { r.U32.Store(uint32(b)) }

type RMPDKEYR struct{ mmio.UM32 }

func (rm RMPDKEYR) Load() PDKEYR   { return PDKEYR(rm.UM32.Load()) }
func (rm RMPDKEYR) Store(b PDKEYR) { rm.UM32.Store(uint32(b)) }

type KEYR uint32

type RKEYR struct{ mmio.U32 }

func (r *RKEYR) LoadBits(mask KEYR) KEYR { return KEYR(r.U32.LoadBits(uint32(mask))) }
func (r *RKEYR) StoreBits(mask, b KEYR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR) SetBits(mask KEYR)       { r.U32.SetBits(uint32(mask)) }
func (r *RKEYR) ClearBits(mask KEYR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RKEYR) Load() KEYR              { return KEYR(r.U32.Load()) }
func (r *RKEYR) Store(b KEYR)            { r.U32.Store(uint32(b)) }

type RMKEYR struct{ mmio.UM32 }

func (rm RMKEYR) Load() KEYR   { return KEYR(rm.UM32.Load()) }
func (rm RMKEYR) Store(b KEYR) { rm.UM32.Store(uint32(b)) }

type OPTKEYR uint32

type ROPTKEYR struct{ mmio.U32 }

func (r *ROPTKEYR) LoadBits(mask OPTKEYR) OPTKEYR { return OPTKEYR(r.U32.LoadBits(uint32(mask))) }
func (r *ROPTKEYR) StoreBits(mask, b OPTKEYR)     { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *ROPTKEYR) SetBits(mask OPTKEYR)          { r.U32.SetBits(uint32(mask)) }
func (r *ROPTKEYR) ClearBits(mask OPTKEYR)        { r.U32.ClearBits(uint32(mask)) }
func (r *ROPTKEYR) Load() OPTKEYR                 { return OPTKEYR(r.U32.Load()) }
func (r *ROPTKEYR) Store(b OPTKEYR)               { r.U32.Store(uint32(b)) }

type RMOPTKEYR struct{ mmio.UM32 }

func (rm RMOPTKEYR) Load() OPTKEYR   { return OPTKEYR(rm.UM32.Load()) }
func (rm RMOPTKEYR) Store(b OPTKEYR) { rm.UM32.Store(uint32(b)) }

type SR uint32

type RSR struct{ mmio.U32 }

func (r *RSR) LoadBits(mask SR) SR  { return SR(r.U32.LoadBits(uint32(mask))) }
func (r *RSR) StoreBits(mask, b SR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR) SetBits(mask SR)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR) ClearBits(mask SR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR) Load() SR             { return SR(r.U32.Load()) }
func (r *RSR) Store(b SR)           { r.U32.Store(uint32(b)) }

type RMSR struct{ mmio.UM32 }

func (rm RMSR) Load() SR   { return SR(rm.UM32.Load()) }
func (rm RMSR) Store(b SR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) EOP() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(EOP)}}
}

func (p *Periph) OPERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(OPERR)}}
}

func (p *Periph) PROGERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(PROGERR)}}
}

func (p *Periph) WRPERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(WRPERR)}}
}

func (p *Periph) PGAERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(PGAERR)}}
}

func (p *Periph) SIZERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(SIZERR)}}
}

func (p *Periph) PGSERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(PGSERR)}}
}

func (p *Periph) MISERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(MISERR)}}
}

func (p *Periph) FASTERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(FASTERR)}}
}

func (p *Periph) RDERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(RDERR)}}
}

func (p *Periph) OPTVERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(OPTVERR)}}
}

func (p *Periph) BSY() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(BSY)}}
}

type CR uint32

type RCR struct{ mmio.U32 }

func (r *RCR) LoadBits(mask CR) CR  { return CR(r.U32.LoadBits(uint32(mask))) }
func (r *RCR) StoreBits(mask, b CR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR) SetBits(mask CR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR) ClearBits(mask CR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR) Load() CR             { return CR(r.U32.Load()) }
func (r *RCR) Store(b CR)           { r.U32.Store(uint32(b)) }

type RMCR struct{ mmio.UM32 }

func (rm RMCR) Load() CR   { return CR(rm.UM32.Load()) }
func (rm RMCR) Store(b CR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) PG() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(PG)}}
}

func (p *Periph) PER() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(PER)}}
}

func (p *Periph) MER1() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(MER1)}}
}

func (p *Periph) PNB() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(PNB)}}
}

func (p *Periph) STRT() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(STRT)}}
}

func (p *Periph) OPTSTRT() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(OPTSTRT)}}
}

func (p *Periph) FSTPG() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(FSTPG)}}
}

func (p *Periph) EOPIE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(EOPIE)}}
}

func (p *Periph) ERRIE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ERRIE)}}
}

func (p *Periph) RDERRIE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(RDERRIE)}}
}

func (p *Periph) OBL_LAUNCH() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(OBL_LAUNCH)}}
}

func (p *Periph) SEC_PROT1() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(SEC_PROT1)}}
}

func (p *Periph) OPTLOCK() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(OPTLOCK)}}
}

func (p *Periph) LOCK() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(LOCK)}}
}

type ECCR uint32

type RECCR struct{ mmio.U32 }

func (r *RECCR) LoadBits(mask ECCR) ECCR { return ECCR(r.U32.LoadBits(uint32(mask))) }
func (r *RECCR) StoreBits(mask, b ECCR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RECCR) SetBits(mask ECCR)       { r.U32.SetBits(uint32(mask)) }
func (r *RECCR) ClearBits(mask ECCR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RECCR) Load() ECCR              { return ECCR(r.U32.Load()) }
func (r *RECCR) Store(b ECCR)            { r.U32.Store(uint32(b)) }

type RMECCR struct{ mmio.UM32 }

func (rm RMECCR) Load() ECCR   { return ECCR(rm.UM32.Load()) }
func (rm RMECCR) Store(b ECCR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) ADDR_ECC() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(ADDR_ECC)}}
}

func (p *Periph) BK_ECC() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(BK_ECC)}}
}

func (p *Periph) SYSF_ECC() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(SYSF_ECC)}}
}

func (p *Periph) ECCIE() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(ECCIE)}}
}

func (p *Periph) ECCC2() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(ECCC2)}}
}

func (p *Periph) ECCD2() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(ECCD2)}}
}

func (p *Periph) ECCC() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(ECCC)}}
}

func (p *Periph) ECCD() RMECCR {
	return RMECCR{mmio.UM32{&p.ECCR.U32, uint32(ECCD)}}
}

type OPTR uint32

type ROPTR struct{ mmio.U32 }

func (r *ROPTR) LoadBits(mask OPTR) OPTR { return OPTR(r.U32.LoadBits(uint32(mask))) }
func (r *ROPTR) StoreBits(mask, b OPTR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *ROPTR) SetBits(mask OPTR)       { r.U32.SetBits(uint32(mask)) }
func (r *ROPTR) ClearBits(mask OPTR)     { r.U32.ClearBits(uint32(mask)) }
func (r *ROPTR) Load() OPTR              { return OPTR(r.U32.Load()) }
func (r *ROPTR) Store(b OPTR)            { r.U32.Store(uint32(b)) }

type RMOPTR struct{ mmio.UM32 }

func (rm RMOPTR) Load() OPTR   { return OPTR(rm.UM32.Load()) }
func (rm RMOPTR) Store(b OPTR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) RDP() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(RDP)}}
}

func (p *Periph) BOR_LEV() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(BOR_LEV)}}
}

func (p *Periph) nRST_STOP() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(nRST_STOP)}}
}

func (p *Periph) nRST_STDBY() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(nRST_STDBY)}}
}

func (p *Periph) nRST_SHDW() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(nRST_SHDW)}}
}

func (p *Periph) IDWG_SW() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(IDWG_SW)}}
}

func (p *Periph) IWDG_STOP() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(IWDG_STOP)}}
}

func (p *Periph) IWDG_STDBY() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(IWDG_STDBY)}}
}

func (p *Periph) WWDG_SW() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(WWDG_SW)}}
}

func (p *Periph) nBOOT1() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(nBOOT1)}}
}

func (p *Periph) SRAM2_PE() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(SRAM2_PE)}}
}

func (p *Periph) SRAM2_RST() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(SRAM2_RST)}}
}

func (p *Periph) nSWBOOT0() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(nSWBOOT0)}}
}

func (p *Periph) nBOOT0() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(nBOOT0)}}
}

func (p *Periph) NRST_MODE() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(NRST_MODE)}}
}

func (p *Periph) IRHEN() RMOPTR {
	return RMOPTR{mmio.UM32{&p.OPTR.U32, uint32(IRHEN)}}
}

type PCROP1SR uint32

type RPCROP1SR struct{ mmio.U32 }

func (r *RPCROP1SR) LoadBits(mask PCROP1SR) PCROP1SR { return PCROP1SR(r.U32.LoadBits(uint32(mask))) }
func (r *RPCROP1SR) StoreBits(mask, b PCROP1SR)      { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPCROP1SR) SetBits(mask PCROP1SR)           { r.U32.SetBits(uint32(mask)) }
func (r *RPCROP1SR) ClearBits(mask PCROP1SR)         { r.U32.ClearBits(uint32(mask)) }
func (r *RPCROP1SR) Load() PCROP1SR                  { return PCROP1SR(r.U32.Load()) }
func (r *RPCROP1SR) Store(b PCROP1SR)                { r.U32.Store(uint32(b)) }

type RMPCROP1SR struct{ mmio.UM32 }

func (rm RMPCROP1SR) Load() PCROP1SR   { return PCROP1SR(rm.UM32.Load()) }
func (rm RMPCROP1SR) Store(b PCROP1SR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) PCROP1_STRT() RMPCROP1SR {
	return RMPCROP1SR{mmio.UM32{&p.PCROP1SR.U32, uint32(PCROP1_STRT)}}
}

type PCROP1ER uint32

type RPCROP1ER struct{ mmio.U32 }

func (r *RPCROP1ER) LoadBits(mask PCROP1ER) PCROP1ER { return PCROP1ER(r.U32.LoadBits(uint32(mask))) }
func (r *RPCROP1ER) StoreBits(mask, b PCROP1ER)      { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPCROP1ER) SetBits(mask PCROP1ER)           { r.U32.SetBits(uint32(mask)) }
func (r *RPCROP1ER) ClearBits(mask PCROP1ER)         { r.U32.ClearBits(uint32(mask)) }
func (r *RPCROP1ER) Load() PCROP1ER                  { return PCROP1ER(r.U32.Load()) }
func (r *RPCROP1ER) Store(b PCROP1ER)                { r.U32.Store(uint32(b)) }

type RMPCROP1ER struct{ mmio.UM32 }

func (rm RMPCROP1ER) Load() PCROP1ER   { return PCROP1ER(rm.UM32.Load()) }
func (rm RMPCROP1ER) Store(b PCROP1ER) { rm.UM32.Store(uint32(b)) }

func (p *Periph) PCROP1_END() RMPCROP1ER {
	return RMPCROP1ER{mmio.UM32{&p.PCROP1ER.U32, uint32(PCROP1_END)}}
}

func (p *Periph) PCROP_RDP() RMPCROP1ER {
	return RMPCROP1ER{mmio.UM32{&p.PCROP1ER.U32, uint32(PCROP_RDP)}}
}

type WRP1AR uint32

type RWRP1AR struct{ mmio.U32 }

func (r *RWRP1AR) LoadBits(mask WRP1AR) WRP1AR { return WRP1AR(r.U32.LoadBits(uint32(mask))) }
func (r *RWRP1AR) StoreBits(mask, b WRP1AR)    { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RWRP1AR) SetBits(mask WRP1AR)         { r.U32.SetBits(uint32(mask)) }
func (r *RWRP1AR) ClearBits(mask WRP1AR)       { r.U32.ClearBits(uint32(mask)) }
func (r *RWRP1AR) Load() WRP1AR                { return WRP1AR(r.U32.Load()) }
func (r *RWRP1AR) Store(b WRP1AR)              { r.U32.Store(uint32(b)) }

type RMWRP1AR struct{ mmio.UM32 }

func (rm RMWRP1AR) Load() WRP1AR   { return WRP1AR(rm.UM32.Load()) }
func (rm RMWRP1AR) Store(b WRP1AR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) WRP1A_STRT() RMWRP1AR {
	return RMWRP1AR{mmio.UM32{&p.WRP1AR.U32, uint32(WRP1A_STRT)}}
}

func (p *Periph) WRP1A_END() RMWRP1AR {
	return RMWRP1AR{mmio.UM32{&p.WRP1AR.U32, uint32(WRP1A_END)}}
}

type WRP1BR uint32

type RWRP1BR struct{ mmio.U32 }

func (r *RWRP1BR) LoadBits(mask WRP1BR) WRP1BR { return WRP1BR(r.U32.LoadBits(uint32(mask))) }
func (r *RWRP1BR) StoreBits(mask, b WRP1BR)    { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RWRP1BR) SetBits(mask WRP1BR)         { r.U32.SetBits(uint32(mask)) }
func (r *RWRP1BR) ClearBits(mask WRP1BR)       { r.U32.ClearBits(uint32(mask)) }
func (r *RWRP1BR) Load() WRP1BR                { return WRP1BR(r.U32.Load()) }
func (r *RWRP1BR) Store(b WRP1BR)              { r.U32.Store(uint32(b)) }

type RMWRP1BR struct{ mmio.UM32 }

func (rm RMWRP1BR) Load() WRP1BR   { return WRP1BR(rm.UM32.Load()) }
func (rm RMWRP1BR) Store(b WRP1BR) { rm.UM32.Store(uint32(b)) }

func (p *Periph) WRP1B_STRT() RMWRP1BR {
	return RMWRP1BR{mmio.UM32{&p.WRP1BR.U32, uint32(WRP1B_STRT)}}
}

func (p *Periph) WRP1B_END() RMWRP1BR {
	return RMWRP1BR{mmio.UM32{&p.WRP1BR.U32, uint32(WRP1B_END)}}
}

type SEC1R uint32

type RSEC1R struct{ mmio.U32 }

func (r *RSEC1R) LoadBits(mask SEC1R) SEC1R { return SEC1R(r.U32.LoadBits(uint32(mask))) }
func (r *RSEC1R) StoreBits(mask, b SEC1R)   { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSEC1R) SetBits(mask SEC1R)        { r.U32.SetBits(uint32(mask)) }
func (r *RSEC1R) ClearBits(mask SEC1R)      { r.U32.ClearBits(uint32(mask)) }
func (r *RSEC1R) Load() SEC1R               { return SEC1R(r.U32.Load()) }
func (r *RSEC1R) Store(b SEC1R)             { r.U32.Store(uint32(b)) }

type RMSEC1R struct{ mmio.UM32 }

func (rm RMSEC1R) Load() SEC1R   { return SEC1R(rm.UM32.Load()) }
func (rm RMSEC1R) Store(b SEC1R) { rm.UM32.Store(uint32(b)) }

func (p *Periph) SEC_SIZE1() RMSEC1R {
	return RMSEC1R{mmio.UM32{&p.SEC1R.U32, uint32(SEC_SIZE1)}}
}

func (p *Periph) BOOT_LOCK() RMSEC1R {
	return RMSEC1R{mmio.UM32{&p.SEC1R.U32, uint32(BOOT_LOCK)}}
}
