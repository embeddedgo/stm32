// DO NOT EDIT THIS FILE. GENERATED BY xgen.

//go:build stm32g471xx

package tim1

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	CR1   RCR1
	CR2   RCR2
	SMCR  RSMCR
	DIER  RDIER
	SR    RSR
	EGR   REGR
	CCMR1 RCCMR1
	CCMR2 RCCMR2
	CCER  RCCER
	CNT   RCNT
	PSC   RPSC
	ARR   RARR
	RCR   RRCR
	CCR1  RCCR
	CCR2  RCCR
	CCR3  RCCR
	CCR4  RCCR
	BDTR  RBDTR
	CCR5  RCCR
	CCR6  RCCR
	CCMR3 RCCMR3
	DTR2  RDTR2
	ECR   RECR
	TISEL RTISEL
	AF1   RAF1
	AF2   RAF2
	_     [221]uint32
	DCR   RDCR
	DMAR  RDMAR
}

func TIM1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.TIM1_BASE))) }
func TIM8() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.TIM8_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	return bus.APB2
}

type CR1 uint32

type RCR1 struct{ mmio.U32 }

func (r *RCR1) LoadBits(mask CR1) CR1 { return CR1(r.U32.LoadBits(uint32(mask))) }
func (r *RCR1) StoreBits(mask, b CR1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR1) SetBits(mask CR1)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR1) ClearBits(mask CR1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR1) Load() CR1             { return CR1(r.U32.Load()) }
func (r *RCR1) Store(b CR1)           { r.U32.Store(uint32(b)) }

type RMCR1 struct{ mmio.UM32 }

func (rm RMCR1) Load() CR1   { return CR1(rm.UM32.Load()) }
func (rm RMCR1) Store(b CR1) { rm.UM32.Store(uint32(b)) }

func CEN_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(CEN)}}
}

func UDIS_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(UDIS)}}
}

func URS_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(URS)}}
}

func OPM_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(OPM)}}
}

func DIR_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(DIR)}}
}

func CMS_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(CMS)}}
}

func ARPE_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(ARPE)}}
}

func CKD_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(CKD)}}
}

func UIFREMAP_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(UIFREMAP)}}
}

func DITHEN_(p *Periph) RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(DITHEN)}}
}

type CR2 uint32

type RCR2 struct{ mmio.U32 }

func (r *RCR2) LoadBits(mask CR2) CR2 { return CR2(r.U32.LoadBits(uint32(mask))) }
func (r *RCR2) StoreBits(mask, b CR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR2) SetBits(mask CR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR2) ClearBits(mask CR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR2) Load() CR2             { return CR2(r.U32.Load()) }
func (r *RCR2) Store(b CR2)           { r.U32.Store(uint32(b)) }

type RMCR2 struct{ mmio.UM32 }

func (rm RMCR2) Load() CR2   { return CR2(rm.UM32.Load()) }
func (rm RMCR2) Store(b CR2) { rm.UM32.Store(uint32(b)) }

func CCPC_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(CCPC)}}
}

func CCUS_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(CCUS)}}
}

func CCDS_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(CCDS)}}
}

func MMS_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(MMS)}}
}

func TI1S_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(TI1S)}}
}

func OIS1_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS1)}}
}

func OIS1N_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS1N)}}
}

func OIS2_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS2)}}
}

func OIS2N_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS2N)}}
}

func OIS3_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS3)}}
}

func OIS3N_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS3N)}}
}

func OIS4_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS4)}}
}

func OIS4N_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS4N)}}
}

func OIS5_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS5)}}
}

func OIS6_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(OIS6)}}
}

func MMS2_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(MMS2)}}
}

func MMS_3_(p *Periph) RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(MMS_3)}}
}

type SMCR uint32

type RSMCR struct{ mmio.U32 }

func (r *RSMCR) LoadBits(mask SMCR) SMCR { return SMCR(r.U32.LoadBits(uint32(mask))) }
func (r *RSMCR) StoreBits(mask, b SMCR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSMCR) SetBits(mask SMCR)       { r.U32.SetBits(uint32(mask)) }
func (r *RSMCR) ClearBits(mask SMCR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RSMCR) Load() SMCR              { return SMCR(r.U32.Load()) }
func (r *RSMCR) Store(b SMCR)            { r.U32.Store(uint32(b)) }

type RMSMCR struct{ mmio.UM32 }

func (rm RMSMCR) Load() SMCR   { return SMCR(rm.UM32.Load()) }
func (rm RMSMCR) Store(b SMCR) { rm.UM32.Store(uint32(b)) }

func SMS_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(SMS)}}
}

func OCCS_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(OCCS)}}
}

func TS_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(TS)}}
}

func MSM_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(MSM)}}
}

func ETF_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(ETF)}}
}

func ETPS_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(ETPS)}}
}

func ECE_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(ECE)}}
}

func ETP_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(ETP)}}
}

func SMS_3_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(SMS_3)}}
}

func TS_4_3_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(TS_4_3)}}
}

func SMSPE_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(SMSPE)}}
}

func SMSPS_(p *Periph) RMSMCR {
	return RMSMCR{mmio.UM32{&p.SMCR.U32, uint32(SMSPS)}}
}

type DIER uint32

type RDIER struct{ mmio.U32 }

func (r *RDIER) LoadBits(mask DIER) DIER { return DIER(r.U32.LoadBits(uint32(mask))) }
func (r *RDIER) StoreBits(mask, b DIER)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDIER) SetBits(mask DIER)       { r.U32.SetBits(uint32(mask)) }
func (r *RDIER) ClearBits(mask DIER)     { r.U32.ClearBits(uint32(mask)) }
func (r *RDIER) Load() DIER              { return DIER(r.U32.Load()) }
func (r *RDIER) Store(b DIER)            { r.U32.Store(uint32(b)) }

type RMDIER struct{ mmio.UM32 }

func (rm RMDIER) Load() DIER   { return DIER(rm.UM32.Load()) }
func (rm RMDIER) Store(b DIER) { rm.UM32.Store(uint32(b)) }

func UIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(UIE)}}
}

func CC1IE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC1IE)}}
}

func CC2IE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC2IE)}}
}

func CC3IE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC3IE)}}
}

func CC4IE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC4IE)}}
}

func COMIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(COMIE)}}
}

func TIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(TIE)}}
}

func BIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(BIE)}}
}

func UDE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(UDE)}}
}

func CC1DE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC1DE)}}
}

func CC2DE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC2DE)}}
}

func CC3DE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC3DE)}}
}

func CC4DE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(CC4DE)}}
}

func COMDE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(COMDE)}}
}

func TDE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(TDE)}}
}

func IDXIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(IDXIE)}}
}

func DIRIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(DIRIE)}}
}

func IERRIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(IERRIE)}}
}

func TERRIE_(p *Periph) RMDIER {
	return RMDIER{mmio.UM32{&p.DIER.U32, uint32(TERRIE)}}
}

type SR uint32

type RSR struct{ mmio.U32 }

func (r *RSR) LoadBits(mask SR) SR  { return SR(r.U32.LoadBits(uint32(mask))) }
func (r *RSR) StoreBits(mask, b SR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR) SetBits(mask SR)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR) ClearBits(mask SR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR) Load() SR             { return SR(r.U32.Load()) }
func (r *RSR) Store(b SR)           { r.U32.Store(uint32(b)) }

type RMSR struct{ mmio.UM32 }

func (rm RMSR) Load() SR   { return SR(rm.UM32.Load()) }
func (rm RMSR) Store(b SR) { rm.UM32.Store(uint32(b)) }

func UIF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(UIF)}}
}

func CC1IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC1IF)}}
}

func CC2IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC2IF)}}
}

func CC3IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC3IF)}}
}

func CC4IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC4IF)}}
}

func COMIF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(COMIF)}}
}

func TIF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(TIF)}}
}

func BIF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(BIF)}}
}

func B2IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(B2IF)}}
}

func CC1OF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC1OF)}}
}

func CC2OF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC2OF)}}
}

func CC3OF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC3OF)}}
}

func CC4OF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC4OF)}}
}

func SBIF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(SBIF)}}
}

func CC5IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC5IF)}}
}

func CC6IF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CC6IF)}}
}

func IDXF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(IDXF)}}
}

func DIRF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(DIRF)}}
}

func IERRF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(IERRF)}}
}

func TERRF_(p *Periph) RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(TERRF)}}
}

type EGR uint32

type REGR struct{ mmio.U32 }

func (r *REGR) LoadBits(mask EGR) EGR { return EGR(r.U32.LoadBits(uint32(mask))) }
func (r *REGR) StoreBits(mask, b EGR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *REGR) SetBits(mask EGR)      { r.U32.SetBits(uint32(mask)) }
func (r *REGR) ClearBits(mask EGR)    { r.U32.ClearBits(uint32(mask)) }
func (r *REGR) Load() EGR             { return EGR(r.U32.Load()) }
func (r *REGR) Store(b EGR)           { r.U32.Store(uint32(b)) }

type RMEGR struct{ mmio.UM32 }

func (rm RMEGR) Load() EGR   { return EGR(rm.UM32.Load()) }
func (rm RMEGR) Store(b EGR) { rm.UM32.Store(uint32(b)) }

func UG_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(UG)}}
}

func CC1G_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(CC1G)}}
}

func CC2G_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(CC2G)}}
}

func CC3G_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(CC3G)}}
}

func CC4G_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(CC4G)}}
}

func COMG_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(COMG)}}
}

func TG_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(TG)}}
}

func BG_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(BG)}}
}

func B2G_(p *Periph) RMEGR {
	return RMEGR{mmio.UM32{&p.EGR.U32, uint32(B2G)}}
}

type CCMR1 uint32

type RCCMR1 struct{ mmio.U32 }

func (r *RCCMR1) LoadBits(mask CCMR1) CCMR1 { return CCMR1(r.U32.LoadBits(uint32(mask))) }
func (r *RCCMR1) StoreBits(mask, b CCMR1)   { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCCMR1) SetBits(mask CCMR1)        { r.U32.SetBits(uint32(mask)) }
func (r *RCCMR1) ClearBits(mask CCMR1)      { r.U32.ClearBits(uint32(mask)) }
func (r *RCCMR1) Load() CCMR1               { return CCMR1(r.U32.Load()) }
func (r *RCCMR1) Store(b CCMR1)             { r.U32.Store(uint32(b)) }

type RMCCMR1 struct{ mmio.UM32 }

func (rm RMCCMR1) Load() CCMR1   { return CCMR1(rm.UM32.Load()) }
func (rm RMCCMR1) Store(b CCMR1) { rm.UM32.Store(uint32(b)) }

func CC1S_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(CC1S)}}
}

func OC1FE_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC1FE)}}
}

func OC1PE_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC1PE)}}
}

func OC1M_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC1M)}}
}

func OC1CE_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC1CE)}}
}

func CC2S_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(CC2S)}}
}

func OC2FE_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC2FE)}}
}

func OC2PE_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC2PE)}}
}

func OC2M_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC2M)}}
}

func OC2CE_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC2CE)}}
}

func OC1M_3_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC1M_3)}}
}

func OC2M_3_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(OC2M_3)}}
}

func ICPCS_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(ICPCS)}}
}

func IC1F_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(IC1F)}}
}

func IC2PSC_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(IC2PSC)}}
}

func IC2F_(p *Periph) RMCCMR1 {
	return RMCCMR1{mmio.UM32{&p.CCMR1.U32, uint32(IC2F)}}
}

type CCMR2 uint32

type RCCMR2 struct{ mmio.U32 }

func (r *RCCMR2) LoadBits(mask CCMR2) CCMR2 { return CCMR2(r.U32.LoadBits(uint32(mask))) }
func (r *RCCMR2) StoreBits(mask, b CCMR2)   { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCCMR2) SetBits(mask CCMR2)        { r.U32.SetBits(uint32(mask)) }
func (r *RCCMR2) ClearBits(mask CCMR2)      { r.U32.ClearBits(uint32(mask)) }
func (r *RCCMR2) Load() CCMR2               { return CCMR2(r.U32.Load()) }
func (r *RCCMR2) Store(b CCMR2)             { r.U32.Store(uint32(b)) }

type RMCCMR2 struct{ mmio.UM32 }

func (rm RMCCMR2) Load() CCMR2   { return CCMR2(rm.UM32.Load()) }
func (rm RMCCMR2) Store(b CCMR2) { rm.UM32.Store(uint32(b)) }

func CC3S_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(CC3S)}}
}

func OC3FE_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC3FE)}}
}

func OC3PE_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC3PE)}}
}

func OC3M_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC3M)}}
}

func OC3CE_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC3CE)}}
}

func CC4S_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(CC4S)}}
}

func OC4FE_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC4FE)}}
}

func OC4PE_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC4PE)}}
}

func OC4M_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC4M)}}
}

func OC4CE_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC4CE)}}
}

func OC3M_3_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC3M_3)}}
}

func OC4M_3_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(OC4M_3)}}
}

func IC3PSC_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(IC3PSC)}}
}

func IC3F_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(IC3F)}}
}

func IC4PSC_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(IC4PSC)}}
}

func IC4F_(p *Periph) RMCCMR2 {
	return RMCCMR2{mmio.UM32{&p.CCMR2.U32, uint32(IC4F)}}
}

type CCER uint32

type RCCER struct{ mmio.U32 }

func (r *RCCER) LoadBits(mask CCER) CCER { return CCER(r.U32.LoadBits(uint32(mask))) }
func (r *RCCER) StoreBits(mask, b CCER)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCCER) SetBits(mask CCER)       { r.U32.SetBits(uint32(mask)) }
func (r *RCCER) ClearBits(mask CCER)     { r.U32.ClearBits(uint32(mask)) }
func (r *RCCER) Load() CCER              { return CCER(r.U32.Load()) }
func (r *RCCER) Store(b CCER)            { r.U32.Store(uint32(b)) }

type RMCCER struct{ mmio.UM32 }

func (rm RMCCER) Load() CCER   { return CCER(rm.UM32.Load()) }
func (rm RMCCER) Store(b CCER) { rm.UM32.Store(uint32(b)) }

func CC1E_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC1E)}}
}

func CC1P_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC1P)}}
}

func CC1NE_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC1NE)}}
}

func CC1NP_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC1NP)}}
}

func CC2E_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC2E)}}
}

func CC2P_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC2P)}}
}

func CC2NE_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC2NE)}}
}

func CC2NP_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC2NP)}}
}

func CC3E_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC3E)}}
}

func CC3P_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC3P)}}
}

func CC3NE_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC3NE)}}
}

func CC3NP_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC3NP)}}
}

func CC4E_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC4E)}}
}

func CC4P_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC4P)}}
}

func CC4NE_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC4NE)}}
}

func CC4NP_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC4NP)}}
}

func CC5E_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC5E)}}
}

func CC5P_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC5P)}}
}

func CC6E_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC6E)}}
}

func CC6P_(p *Periph) RMCCER {
	return RMCCER{mmio.UM32{&p.CCER.U32, uint32(CC6P)}}
}

type CNT uint32

type RCNT struct{ mmio.U32 }

func (r *RCNT) LoadBits(mask CNT) CNT { return CNT(r.U32.LoadBits(uint32(mask))) }
func (r *RCNT) StoreBits(mask, b CNT) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCNT) SetBits(mask CNT)      { r.U32.SetBits(uint32(mask)) }
func (r *RCNT) ClearBits(mask CNT)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCNT) Load() CNT             { return CNT(r.U32.Load()) }
func (r *RCNT) Store(b CNT)           { r.U32.Store(uint32(b)) }

type RMCNT struct{ mmio.UM32 }

func (rm RMCNT) Load() CNT   { return CNT(rm.UM32.Load()) }
func (rm RMCNT) Store(b CNT) { rm.UM32.Store(uint32(b)) }

type PSC uint32

type RPSC struct{ mmio.U32 }

func (r *RPSC) LoadBits(mask PSC) PSC { return PSC(r.U32.LoadBits(uint32(mask))) }
func (r *RPSC) StoreBits(mask, b PSC) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPSC) SetBits(mask PSC)      { r.U32.SetBits(uint32(mask)) }
func (r *RPSC) ClearBits(mask PSC)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPSC) Load() PSC             { return PSC(r.U32.Load()) }
func (r *RPSC) Store(b PSC)           { r.U32.Store(uint32(b)) }

type RMPSC struct{ mmio.UM32 }

func (rm RMPSC) Load() PSC   { return PSC(rm.UM32.Load()) }
func (rm RMPSC) Store(b PSC) { rm.UM32.Store(uint32(b)) }

type ARR uint32

type RARR struct{ mmio.U32 }

func (r *RARR) LoadBits(mask ARR) ARR { return ARR(r.U32.LoadBits(uint32(mask))) }
func (r *RARR) StoreBits(mask, b ARR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RARR) SetBits(mask ARR)      { r.U32.SetBits(uint32(mask)) }
func (r *RARR) ClearBits(mask ARR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RARR) Load() ARR             { return ARR(r.U32.Load()) }
func (r *RARR) Store(b ARR)           { r.U32.Store(uint32(b)) }

type RMARR struct{ mmio.UM32 }

func (rm RMARR) Load() ARR   { return ARR(rm.UM32.Load()) }
func (rm RMARR) Store(b ARR) { rm.UM32.Store(uint32(b)) }

type RCR uint32

type RRCR struct{ mmio.U32 }

func (r *RRCR) LoadBits(mask RCR) RCR { return RCR(r.U32.LoadBits(uint32(mask))) }
func (r *RRCR) StoreBits(mask, b RCR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RRCR) SetBits(mask RCR)      { r.U32.SetBits(uint32(mask)) }
func (r *RRCR) ClearBits(mask RCR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RRCR) Load() RCR             { return RCR(r.U32.Load()) }
func (r *RRCR) Store(b RCR)           { r.U32.Store(uint32(b)) }

type RMRCR struct{ mmio.UM32 }

func (rm RMRCR) Load() RCR   { return RCR(rm.UM32.Load()) }
func (rm RMRCR) Store(b RCR) { rm.UM32.Store(uint32(b)) }

type CCR uint32

type RCCR struct{ mmio.U32 }

func (r *RCCR) LoadBits(mask CCR) CCR { return CCR(r.U32.LoadBits(uint32(mask))) }
func (r *RCCR) StoreBits(mask, b CCR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCCR) SetBits(mask CCR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCCR) ClearBits(mask CCR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCCR) Load() CCR             { return CCR(r.U32.Load()) }
func (r *RCCR) Store(b CCR)           { r.U32.Store(uint32(b)) }

type RMCCR struct{ mmio.UM32 }

func (rm RMCCR) Load() CCR   { return CCR(rm.UM32.Load()) }
func (rm RMCCR) Store(b CCR) { rm.UM32.Store(uint32(b)) }

type BDTR uint32

type RBDTR struct{ mmio.U32 }

func (r *RBDTR) LoadBits(mask BDTR) BDTR { return BDTR(r.U32.LoadBits(uint32(mask))) }
func (r *RBDTR) StoreBits(mask, b BDTR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RBDTR) SetBits(mask BDTR)       { r.U32.SetBits(uint32(mask)) }
func (r *RBDTR) ClearBits(mask BDTR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RBDTR) Load() BDTR              { return BDTR(r.U32.Load()) }
func (r *RBDTR) Store(b BDTR)            { r.U32.Store(uint32(b)) }

type RMBDTR struct{ mmio.UM32 }

func (rm RMBDTR) Load() BDTR   { return BDTR(rm.UM32.Load()) }
func (rm RMBDTR) Store(b BDTR) { rm.UM32.Store(uint32(b)) }

func DTG_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(DTG)}}
}

func LOCK_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(LOCK)}}
}

func OSSI_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(OSSI)}}
}

func OSSR_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(OSSR)}}
}

func BKE_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BKE)}}
}

func BKP_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BKP)}}
}

func AOE_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(AOE)}}
}

func MOE_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(MOE)}}
}

func BKF_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BKF)}}
}

func BK2F_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BK2F)}}
}

func BK2E_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BK2E)}}
}

func BK2P_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BK2P)}}
}

func BKDSRM_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BKDSRM)}}
}

func BK2DSRM_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BK2DSRM)}}
}

func BKBID_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BKBID)}}
}

func BK2ID_(p *Periph) RMBDTR {
	return RMBDTR{mmio.UM32{&p.BDTR.U32, uint32(BK2ID)}}
}

type CCMR3 uint32

type RCCMR3 struct{ mmio.U32 }

func (r *RCCMR3) LoadBits(mask CCMR3) CCMR3 { return CCMR3(r.U32.LoadBits(uint32(mask))) }
func (r *RCCMR3) StoreBits(mask, b CCMR3)   { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCCMR3) SetBits(mask CCMR3)        { r.U32.SetBits(uint32(mask)) }
func (r *RCCMR3) ClearBits(mask CCMR3)      { r.U32.ClearBits(uint32(mask)) }
func (r *RCCMR3) Load() CCMR3               { return CCMR3(r.U32.Load()) }
func (r *RCCMR3) Store(b CCMR3)             { r.U32.Store(uint32(b)) }

type RMCCMR3 struct{ mmio.UM32 }

func (rm RMCCMR3) Load() CCMR3   { return CCMR3(rm.UM32.Load()) }
func (rm RMCCMR3) Store(b CCMR3) { rm.UM32.Store(uint32(b)) }

func OC5FE_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC5FE)}}
}

func OC5PE_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC5PE)}}
}

func OC5M_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC5M)}}
}

func OC5CE_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC5CE)}}
}

func OC6FE_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC6FE)}}
}

func OC6PE_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC6PE)}}
}

func OC6M_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC6M)}}
}

func OC6CE_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC6CE)}}
}

func OC5M_bit3_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC5M_bit3)}}
}

func OC6M_bit3_(p *Periph) RMCCMR3 {
	return RMCCMR3{mmio.UM32{&p.CCMR3.U32, uint32(OC6M_bit3)}}
}

type DTR2 uint32

type RDTR2 struct{ mmio.U32 }

func (r *RDTR2) LoadBits(mask DTR2) DTR2 { return DTR2(r.U32.LoadBits(uint32(mask))) }
func (r *RDTR2) StoreBits(mask, b DTR2)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDTR2) SetBits(mask DTR2)       { r.U32.SetBits(uint32(mask)) }
func (r *RDTR2) ClearBits(mask DTR2)     { r.U32.ClearBits(uint32(mask)) }
func (r *RDTR2) Load() DTR2              { return DTR2(r.U32.Load()) }
func (r *RDTR2) Store(b DTR2)            { r.U32.Store(uint32(b)) }

type RMDTR2 struct{ mmio.UM32 }

func (rm RMDTR2) Load() DTR2   { return DTR2(rm.UM32.Load()) }
func (rm RMDTR2) Store(b DTR2) { rm.UM32.Store(uint32(b)) }

func DTGF_(p *Periph) RMDTR2 {
	return RMDTR2{mmio.UM32{&p.DTR2.U32, uint32(DTGF)}}
}

func DTAE_(p *Periph) RMDTR2 {
	return RMDTR2{mmio.UM32{&p.DTR2.U32, uint32(DTAE)}}
}

func DTPE_(p *Periph) RMDTR2 {
	return RMDTR2{mmio.UM32{&p.DTR2.U32, uint32(DTPE)}}
}

type ECR uint32

type RECR struct{ mmio.U32 }

func (r *RECR) LoadBits(mask ECR) ECR { return ECR(r.U32.LoadBits(uint32(mask))) }
func (r *RECR) StoreBits(mask, b ECR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RECR) SetBits(mask ECR)      { r.U32.SetBits(uint32(mask)) }
func (r *RECR) ClearBits(mask ECR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RECR) Load() ECR             { return ECR(r.U32.Load()) }
func (r *RECR) Store(b ECR)           { r.U32.Store(uint32(b)) }

type RMECR struct{ mmio.UM32 }

func (rm RMECR) Load() ECR   { return ECR(rm.UM32.Load()) }
func (rm RMECR) Store(b ECR) { rm.UM32.Store(uint32(b)) }

func IE_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(IE)}}
}

func IDIR_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(IDIR)}}
}

func IBLK_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(IBLK)}}
}

func FIDX_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(FIDX)}}
}

func IPOS_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(IPOS)}}
}

func PW_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(PW)}}
}

func PWPRSC_(p *Periph) RMECR {
	return RMECR{mmio.UM32{&p.ECR.U32, uint32(PWPRSC)}}
}

type TISEL uint32

type RTISEL struct{ mmio.U32 }

func (r *RTISEL) LoadBits(mask TISEL) TISEL { return TISEL(r.U32.LoadBits(uint32(mask))) }
func (r *RTISEL) StoreBits(mask, b TISEL)   { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RTISEL) SetBits(mask TISEL)        { r.U32.SetBits(uint32(mask)) }
func (r *RTISEL) ClearBits(mask TISEL)      { r.U32.ClearBits(uint32(mask)) }
func (r *RTISEL) Load() TISEL               { return TISEL(r.U32.Load()) }
func (r *RTISEL) Store(b TISEL)             { r.U32.Store(uint32(b)) }

type RMTISEL struct{ mmio.UM32 }

func (rm RMTISEL) Load() TISEL   { return TISEL(rm.UM32.Load()) }
func (rm RMTISEL) Store(b TISEL) { rm.UM32.Store(uint32(b)) }

func TI1SEL_(p *Periph) RMTISEL {
	return RMTISEL{mmio.UM32{&p.TISEL.U32, uint32(TI1SEL)}}
}

func TI2SEL_(p *Periph) RMTISEL {
	return RMTISEL{mmio.UM32{&p.TISEL.U32, uint32(TI2SEL)}}
}

func TI3SEL_(p *Periph) RMTISEL {
	return RMTISEL{mmio.UM32{&p.TISEL.U32, uint32(TI3SEL)}}
}

func TI4SEL_(p *Periph) RMTISEL {
	return RMTISEL{mmio.UM32{&p.TISEL.U32, uint32(TI4SEL)}}
}

type AF1 uint32

type RAF1 struct{ mmio.U32 }

func (r *RAF1) LoadBits(mask AF1) AF1 { return AF1(r.U32.LoadBits(uint32(mask))) }
func (r *RAF1) StoreBits(mask, b AF1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RAF1) SetBits(mask AF1)      { r.U32.SetBits(uint32(mask)) }
func (r *RAF1) ClearBits(mask AF1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RAF1) Load() AF1             { return AF1(r.U32.Load()) }
func (r *RAF1) Store(b AF1)           { r.U32.Store(uint32(b)) }

type RMAF1 struct{ mmio.UM32 }

func (rm RMAF1) Load() AF1   { return AF1(rm.UM32.Load()) }
func (rm RMAF1) Store(b AF1) { rm.UM32.Store(uint32(b)) }

func BKINE_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKINE)}}
}

func BKCMP1E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP1E)}}
}

func BKCMP2E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP2E)}}
}

func BKCMP3E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP3E)}}
}

func BKCMP4E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP4E)}}
}

func BKCMP5E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP5E)}}
}

func BKCMP6E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP6E)}}
}

func BKCMP7E_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP7E)}}
}

func BKINP_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKINP)}}
}

func BKCMP1P_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP1P)}}
}

func BKCMP2P_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP2P)}}
}

func BKCMP3P_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP3P)}}
}

func BKCMP4P_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(BKCMP4P)}}
}

func ETRSEL_(p *Periph) RMAF1 {
	return RMAF1{mmio.UM32{&p.AF1.U32, uint32(ETRSEL)}}
}

type AF2 uint32

type RAF2 struct{ mmio.U32 }

func (r *RAF2) LoadBits(mask AF2) AF2 { return AF2(r.U32.LoadBits(uint32(mask))) }
func (r *RAF2) StoreBits(mask, b AF2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RAF2) SetBits(mask AF2)      { r.U32.SetBits(uint32(mask)) }
func (r *RAF2) ClearBits(mask AF2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RAF2) Load() AF2             { return AF2(r.U32.Load()) }
func (r *RAF2) Store(b AF2)           { r.U32.Store(uint32(b)) }

type RMAF2 struct{ mmio.UM32 }

func (rm RMAF2) Load() AF2   { return AF2(rm.UM32.Load()) }
func (rm RMAF2) Store(b AF2) { rm.UM32.Store(uint32(b)) }

func BKINE_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BKINE)}}
}

func BK2CMP1E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP1E)}}
}

func BK2CMP2E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP2E)}}
}

func BK2CMP3E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP3E)}}
}

func BK2CMP4E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP4E)}}
}

func BK2CMP5E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP5E)}}
}

func BK2CMP6E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP6E)}}
}

func BK2CMP7E_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP7E)}}
}

func BK2INP_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2INP)}}
}

func BK2CMP1P_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP1P)}}
}

func BK2CMP2P_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP2P)}}
}

func BK2CMP3P_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP3P)}}
}

func BK2CMP4P_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(BK2CMP4P)}}
}

func OCRSEL_(p *Periph) RMAF2 {
	return RMAF2{mmio.UM32{&p.AF2.U32, uint32(OCRSEL)}}
}

type DCR uint32

type RDCR struct{ mmio.U32 }

func (r *RDCR) LoadBits(mask DCR) DCR { return DCR(r.U32.LoadBits(uint32(mask))) }
func (r *RDCR) StoreBits(mask, b DCR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDCR) SetBits(mask DCR)      { r.U32.SetBits(uint32(mask)) }
func (r *RDCR) ClearBits(mask DCR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RDCR) Load() DCR             { return DCR(r.U32.Load()) }
func (r *RDCR) Store(b DCR)           { r.U32.Store(uint32(b)) }

type RMDCR struct{ mmio.UM32 }

func (rm RMDCR) Load() DCR   { return DCR(rm.UM32.Load()) }
func (rm RMDCR) Store(b DCR) { rm.UM32.Store(uint32(b)) }

func DBA_(p *Periph) RMDCR {
	return RMDCR{mmio.UM32{&p.DCR.U32, uint32(DBA)}}
}

func DBL_(p *Periph) RMDCR {
	return RMDCR{mmio.UM32{&p.DCR.U32, uint32(DBL)}}
}

type DMAR uint32

type RDMAR struct{ mmio.U32 }

func (r *RDMAR) LoadBits(mask DMAR) DMAR { return DMAR(r.U32.LoadBits(uint32(mask))) }
func (r *RDMAR) StoreBits(mask, b DMAR)  { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDMAR) SetBits(mask DMAR)       { r.U32.SetBits(uint32(mask)) }
func (r *RDMAR) ClearBits(mask DMAR)     { r.U32.ClearBits(uint32(mask)) }
func (r *RDMAR) Load() DMAR              { return DMAR(r.U32.Load()) }
func (r *RDMAR) Store(b DMAR)            { r.U32.Store(uint32(b)) }

type RMDMAR struct{ mmio.UM32 }

func (rm RMDMAR) Load() DMAR   { return DMAR(rm.UM32.Load()) }
func (rm RMDMAR) Store(b DMAR) { rm.UM32.Store(uint32(b)) }
