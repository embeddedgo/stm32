// Code generated by svdxgen; DO NOT EDIT.

//go:build stm32h7x3

// Package mdma provides access to the registers of the MDMA peripheral.
//
// Instances:
//
//	MDMA  MDMA_BASE  AHB3  MDMA
//
// Registers:
//
//	0x000 32  MDMA_GISR0     MDMA Global Interrupt/Status Register
//	0x040 32  MDMA_C0ISR     MDMA channel x interrupt/status register
//	0x044 32  MDMA_C0IFCR    MDMA channel x interrupt flag clear register
//	0x048 32  MDMA_C0ESR     MDMA Channel x error status register
//	0x04C 32  MDMA_C0CR      This register is used to control the concerned channel.
//	0x050 32  MDMA_C0TCR     This register is used to configure the concerned channel.
//	0x054 32  MDMA_C0BNDTR   MDMA Channel x block number of data register
//	0x058 32  MDMA_C0SAR     MDMA channel x source address register
//	0x05C 32  MDMA_C0DAR     MDMA channel x destination address register
//	0x060 32  MDMA_C0BRUR    MDMA channel x Block Repeat address Update register
//	0x064 32  MDMA_C0LAR     MDMA channel x Link Address register
//	0x068 32  MDMA_C0TBR     MDMA channel x Trigger and Bus selection Register
//	0x070 32  MDMA_C0MAR     MDMA channel x Mask address register
//	0x074 32  MDMA_C0MDR     MDMA channel x Mask Data register
//	0x080 32  MDMA_C1ISR     MDMA channel x interrupt/status register
//	0x084 32  MDMA_C1IFCR    MDMA channel x interrupt flag clear register
//	0x088 32  MDMA_C1ESR     MDMA Channel x error status register
//	0x08C 32  MDMA_C1CR      This register is used to control the concerned channel.
//	0x090 32  MDMA_C1TCR     This register is used to configure the concerned channel.
//	0x094 32  MDMA_C1BNDTR   MDMA Channel x block number of data register
//	0x098 32  MDMA_C1SAR     MDMA channel x source address register
//	0x09C 32  MDMA_C1DAR     MDMA channel x destination address register
//	0x0A0 32  MDMA_C1BRUR    MDMA channel x Block Repeat address Update register
//	0x0A4 32  MDMA_C1LAR     MDMA channel x Link Address register
//	0x0A8 32  MDMA_C1TBR     MDMA channel x Trigger and Bus selection Register
//	0x0B0 32  MDMA_C1MAR     MDMA channel x Mask address register
//	0x0B4 32  MDMA_C1MDR     MDMA channel x Mask Data register
//	0x0C0 32  MDMA_C2ISR     MDMA channel x interrupt/status register
//	0x0C4 32  MDMA_C2IFCR    MDMA channel x interrupt flag clear register
//	0x0C8 32  MDMA_C2ESR     MDMA Channel x error status register
//	0x0CC 32  MDMA_C2CR      This register is used to control the concerned channel.
//	0x0D0 32  MDMA_C2TCR     This register is used to configure the concerned channel.
//	0x0D4 32  MDMA_C2BNDTR   MDMA Channel x block number of data register
//	0x0D8 32  MDMA_C2SAR     MDMA channel x source address register
//	0x0DC 32  MDMA_C2DAR     MDMA channel x destination address register
//	0x0E0 32  MDMA_C2BRUR    MDMA channel x Block Repeat address Update register
//	0x0E4 32  MDMA_C2LAR     MDMA channel x Link Address register
//	0x0E8 32  MDMA_C2TBR     MDMA channel x Trigger and Bus selection Register
//	0x0F0 32  MDMA_C2MAR     MDMA channel x Mask address register
//	0x0F4 32  MDMA_C2MDR     MDMA channel x Mask Data register
//	0x100 32  MDMA_C3ISR     MDMA channel x interrupt/status register
//	0x104 32  MDMA_C3IFCR    MDMA channel x interrupt flag clear register
//	0x108 32  MDMA_C3ESR     MDMA Channel x error status register
//	0x10C 32  MDMA_C3CR      This register is used to control the concerned channel.
//	0x110 32  MDMA_C3TCR     This register is used to configure the concerned channel.
//	0x114 32  MDMA_C3BNDTR   MDMA Channel x block number of data register
//	0x118 32  MDMA_C3SAR     MDMA channel x source address register
//	0x11C 32  MDMA_C3DAR     MDMA channel x destination address register
//	0x120 32  MDMA_C3BRUR    MDMA channel x Block Repeat address Update register
//	0x124 32  MDMA_C3LAR     MDMA channel x Link Address register
//	0x128 32  MDMA_C3TBR     MDMA channel x Trigger and Bus selection Register
//	0x130 32  MDMA_C3MAR     MDMA channel x Mask address register
//	0x134 32  MDMA_C3MDR     MDMA channel x Mask Data register
//	0x140 32  MDMA_C4ISR     MDMA channel x interrupt/status register
//	0x144 32  MDMA_C4IFCR    MDMA channel x interrupt flag clear register
//	0x148 32  MDMA_C4ESR     MDMA Channel x error status register
//	0x14C 32  MDMA_C4CR      This register is used to control the concerned channel.
//	0x150 32  MDMA_C4TCR     This register is used to configure the concerned channel.
//	0x154 32  MDMA_C4BNDTR   MDMA Channel x block number of data register
//	0x158 32  MDMA_C4SAR     MDMA channel x source address register
//	0x15C 32  MDMA_C4DAR     MDMA channel x destination address register
//	0x160 32  MDMA_C4BRUR    MDMA channel x Block Repeat address Update register
//	0x164 32  MDMA_C4LAR     MDMA channel x Link Address register
//	0x168 32  MDMA_C4TBR     MDMA channel x Trigger and Bus selection Register
//	0x170 32  MDMA_C4MAR     MDMA channel x Mask address register
//	0x174 32  MDMA_C4MDR     MDMA channel x Mask Data register
//	0x180 32  MDMA_C5ISR     MDMA channel x interrupt/status register
//	0x184 32  MDMA_C5IFCR    MDMA channel x interrupt flag clear register
//	0x188 32  MDMA_C5ESR     MDMA Channel x error status register
//	0x18C 32  MDMA_C5CR      This register is used to control the concerned channel.
//	0x190 32  MDMA_C5TCR     This register is used to configure the concerned channel.
//	0x194 32  MDMA_C5BNDTR   MDMA Channel x block number of data register
//	0x198 32  MDMA_C5SAR     MDMA channel x source address register
//	0x19C 32  MDMA_C5DAR     MDMA channel x destination address register
//	0x1A0 32  MDMA_C5BRUR    MDMA channel x Block Repeat address Update register
//	0x1A4 32  MDMA_C5LAR     MDMA channel x Link Address register
//	0x1A8 32  MDMA_C5TBR     MDMA channel x Trigger and Bus selection Register
//	0x1B0 32  MDMA_C5MAR     MDMA channel x Mask address register
//	0x1B4 32  MDMA_C5MDR     MDMA channel x Mask Data register
//	0x1C0 32  MDMA_C6ISR     MDMA channel x interrupt/status register
//	0x1C4 32  MDMA_C6IFCR    MDMA channel x interrupt flag clear register
//	0x1C8 32  MDMA_C6ESR     MDMA Channel x error status register
//	0x1CC 32  MDMA_C6CR      This register is used to control the concerned channel.
//	0x1D0 32  MDMA_C6TCR     This register is used to configure the concerned channel.
//	0x1D4 32  MDMA_C6BNDTR   MDMA Channel x block number of data register
//	0x1D8 32  MDMA_C6SAR     MDMA channel x source address register
//	0x1DC 32  MDMA_C6DAR     MDMA channel x destination address register
//	0x1E0 32  MDMA_C6BRUR    MDMA channel x Block Repeat address Update register
//	0x1E4 32  MDMA_C6LAR     MDMA channel x Link Address register
//	0x1E8 32  MDMA_C6TBR     MDMA channel x Trigger and Bus selection Register
//	0x1F0 32  MDMA_C6MAR     MDMA channel x Mask address register
//	0x1F4 32  MDMA_C6MDR     MDMA channel x Mask Data register
//	0x200 32  MDMA_C7ISR     MDMA channel x interrupt/status register
//	0x204 32  MDMA_C7IFCR    MDMA channel x interrupt flag clear register
//	0x208 32  MDMA_C7ESR     MDMA Channel x error status register
//	0x20C 32  MDMA_C7CR      This register is used to control the concerned channel.
//	0x210 32  MDMA_C7TCR     This register is used to configure the concerned channel.
//	0x214 32  MDMA_C7BNDTR   MDMA Channel x block number of data register
//	0x218 32  MDMA_C7SAR     MDMA channel x source address register
//	0x21C 32  MDMA_C7DAR     MDMA channel x destination address register
//	0x220 32  MDMA_C7BRUR    MDMA channel x Block Repeat address Update register
//	0x224 32  MDMA_C7LAR     MDMA channel x Link Address register
//	0x228 32  MDMA_C7TBR     MDMA channel x Trigger and Bus selection Register
//	0x230 32  MDMA_C7MAR     MDMA channel x Mask address register
//	0x234 32  MDMA_C7MDR     MDMA channel x Mask Data register
//	0x240 32  MDMA_C8ISR     MDMA channel x interrupt/status register
//	0x244 32  MDMA_C8IFCR    MDMA channel x interrupt flag clear register
//	0x248 32  MDMA_C8ESR     MDMA Channel x error status register
//	0x24C 32  MDMA_C8CR      This register is used to control the concerned channel.
//	0x250 32  MDMA_C8TCR     This register is used to configure the concerned channel.
//	0x254 32  MDMA_C8BNDTR   MDMA Channel x block number of data register
//	0x258 32  MDMA_C8SAR     MDMA channel x source address register
//	0x25C 32  MDMA_C8DAR     MDMA channel x destination address register
//	0x260 32  MDMA_C8BRUR    MDMA channel x Block Repeat address Update register
//	0x264 32  MDMA_C8LAR     MDMA channel x Link Address register
//	0x268 32  MDMA_C8TBR     MDMA channel x Trigger and Bus selection Register
//	0x270 32  MDMA_C8MAR     MDMA channel x Mask address register
//	0x274 32  MDMA_C8MDR     MDMA channel x Mask Data register
//	0x280 32  MDMA_C9ISR     MDMA channel x interrupt/status register
//	0x284 32  MDMA_C9IFCR    MDMA channel x interrupt flag clear register
//	0x288 32  MDMA_C9ESR     MDMA Channel x error status register
//	0x28C 32  MDMA_C9CR      This register is used to control the concerned channel.
//	0x290 32  MDMA_C9TCR     This register is used to configure the concerned channel.
//	0x294 32  MDMA_C9BNDTR   MDMA Channel x block number of data register
//	0x298 32  MDMA_C9SAR     MDMA channel x source address register
//	0x29C 32  MDMA_C9DAR     MDMA channel x destination address register
//	0x2A0 32  MDMA_C9BRUR    MDMA channel x Block Repeat address Update register
//	0x2A4 32  MDMA_C9LAR     MDMA channel x Link Address register
//	0x2A8 32  MDMA_C9TBR     MDMA channel x Trigger and Bus selection Register
//	0x2B0 32  MDMA_C9MAR     MDMA channel x Mask address register
//	0x2B4 32  MDMA_C9MDR     MDMA channel x Mask Data register
//	0x2C0 32  MDMA_C10ISR    MDMA channel x interrupt/status register
//	0x2C4 32  MDMA_C10IFCR   MDMA channel x interrupt flag clear register
//	0x2C8 32  MDMA_C10ESR    MDMA Channel x error status register
//	0x2CC 32  MDMA_C10CR     This register is used to control the concerned channel.
//	0x2D0 32  MDMA_C10TCR    This register is used to configure the concerned channel.
//	0x2D4 32  MDMA_C10BNDTR  MDMA Channel x block number of data register
//	0x2D8 32  MDMA_C10SAR    MDMA channel x source address register
//	0x2DC 32  MDMA_C10DAR    MDMA channel x destination address register
//	0x2E0 32  MDMA_C10BRUR   MDMA channel x Block Repeat address Update register
//	0x2E4 32  MDMA_C10LAR    MDMA channel x Link Address register
//	0x2E8 32  MDMA_C10TBR    MDMA channel x Trigger and Bus selection Register
//	0x2F0 32  MDMA_C10MAR    MDMA channel x Mask address register
//	0x2F4 32  MDMA_C10MDR    MDMA channel x Mask Data register
//	0x300 32  MDMA_C11ISR    MDMA channel x interrupt/status register
//	0x304 32  MDMA_C11IFCR   MDMA channel x interrupt flag clear register
//	0x308 32  MDMA_C11ESR    MDMA Channel x error status register
//	0x30C 32  MDMA_C11CR     This register is used to control the concerned channel.
//	0x310 32  MDMA_C11TCR    This register is used to configure the concerned channel.
//	0x314 32  MDMA_C11BNDTR  MDMA Channel x block number of data register
//	0x318 32  MDMA_C11SAR    MDMA channel x source address register
//	0x31C 32  MDMA_C11DAR    MDMA channel x destination address register
//	0x320 32  MDMA_C11BRUR   MDMA channel x Block Repeat address Update register
//	0x324 32  MDMA_C11LAR    MDMA channel x Link Address register
//	0x328 32  MDMA_C11TBR    MDMA channel x Trigger and Bus selection Register
//	0x330 32  MDMA_C11MAR    MDMA channel x Mask address register
//	0x334 32  MDMA_C11MDR    MDMA channel x Mask Data register
//	0x340 32  MDMA_C12ISR    MDMA channel x interrupt/status register
//	0x344 32  MDMA_C12IFCR   MDMA channel x interrupt flag clear register
//	0x348 32  MDMA_C12ESR    MDMA Channel x error status register
//	0x34C 32  MDMA_C12CR     This register is used to control the concerned channel.
//	0x350 32  MDMA_C12TCR    This register is used to configure the concerned channel.
//	0x354 32  MDMA_C12BNDTR  MDMA Channel x block number of data register
//	0x358 32  MDMA_C12SAR    MDMA channel x source address register
//	0x35C 32  MDMA_C12DAR    MDMA channel x destination address register
//	0x360 32  MDMA_C12BRUR   MDMA channel x Block Repeat address Update register
//	0x364 32  MDMA_C12LAR    MDMA channel x Link Address register
//	0x368 32  MDMA_C12TBR    MDMA channel x Trigger and Bus selection Register
//	0x370 32  MDMA_C12MAR    MDMA channel x Mask address register
//	0x374 32  MDMA_C12MDR    MDMA channel x Mask Data register
//	0x380 32  MDMA_C13ISR    MDMA channel x interrupt/status register
//	0x384 32  MDMA_C13IFCR   MDMA channel x interrupt flag clear register
//	0x388 32  MDMA_C13ESR    MDMA Channel x error status register
//	0x38C 32  MDMA_C13CR     This register is used to control the concerned channel.
//	0x390 32  MDMA_C13TCR    This register is used to configure the concerned channel.
//	0x394 32  MDMA_C13BNDTR  MDMA Channel x block number of data register
//	0x398 32  MDMA_C13SAR    MDMA channel x source address register
//	0x39C 32  MDMA_C13DAR    MDMA channel x destination address register
//	0x3A0 32  MDMA_C13BRUR   MDMA channel x Block Repeat address Update register
//	0x3A4 32  MDMA_C13LAR    MDMA channel x Link Address register
//	0x3A8 32  MDMA_C13TBR    MDMA channel x Trigger and Bus selection Register
//	0x3B0 32  MDMA_C13MAR    MDMA channel x Mask address register
//	0x3B4 32  MDMA_C13MDR    MDMA channel x Mask Data register
//	0x3C0 32  MDMA_C14ISR    MDMA channel x interrupt/status register
//	0x3C4 32  MDMA_C14IFCR   MDMA channel x interrupt flag clear register
//	0x3C8 32  MDMA_C14ESR    MDMA Channel x error status register
//	0x3CC 32  MDMA_C14CR     This register is used to control the concerned channel.
//	0x3D0 32  MDMA_C14TCR    This register is used to configure the concerned channel.
//	0x3D4 32  MDMA_C14BNDTR  MDMA Channel x block number of data register
//	0x3D8 32  MDMA_C14SAR    MDMA channel x source address register
//	0x3DC 32  MDMA_C14DAR    MDMA channel x destination address register
//	0x3E0 32  MDMA_C14BRUR   MDMA channel x Block Repeat address Update register
//	0x3E4 32  MDMA_C14LAR    MDMA channel x Link Address register
//	0x3E8 32  MDMA_C14TBR    MDMA channel x Trigger and Bus selection Register
//	0x3F0 32  MDMA_C14MAR    MDMA channel x Mask address register
//	0x3F4 32  MDMA_C14MDR    MDMA channel x Mask Data register
//	0x400 32  MDMA_C15ISR    MDMA channel x interrupt/status register
//	0x404 32  MDMA_C15IFCR   MDMA channel x interrupt flag clear register
//	0x408 32  MDMA_C15ESR    MDMA Channel x error status register
//	0x40C 32  MDMA_C15CR     This register is used to control the concerned channel.
//	0x410 32  MDMA_C15TCR    This register is used to configure the concerned channel.
//	0x414 32  MDMA_C15BNDTR  MDMA Channel x block number of data register
//	0x418 32  MDMA_C15SAR    MDMA channel x source address register
//	0x41C 32  MDMA_C15DAR    MDMA channel x destination address register
//	0x420 32  MDMA_C15BRUR   MDMA channel x Block Repeat address Update register
//	0x424 32  MDMA_C15LAR    MDMA channel x Link Address register
//	0x428 32  MDMA_C15TBR    MDMA channel x Trigger and Bus selection Register
//	0x430 32  MDMA_C15MAR    MDMA channel x Mask address register
//	0x434 32  MDMA_C15MDR    MDMA channel x Mask Data register
//
// Import:
//
//	github.com/embeddedgo/stm32/p/bus
//	github.com/embeddedgo/stm32/p/mmap
package mdma

const (
	GIF0  MDMA_GISR0 = 0x01 << 0  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF1  MDMA_GISR0 = 0x01 << 1  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF2  MDMA_GISR0 = 0x01 << 2  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF3  MDMA_GISR0 = 0x01 << 3  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF4  MDMA_GISR0 = 0x01 << 4  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF5  MDMA_GISR0 = 0x01 << 5  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF6  MDMA_GISR0 = 0x01 << 6  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF7  MDMA_GISR0 = 0x01 << 7  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF8  MDMA_GISR0 = 0x01 << 8  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF9  MDMA_GISR0 = 0x01 << 9  //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF10 MDMA_GISR0 = 0x01 << 10 //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF11 MDMA_GISR0 = 0x01 << 11 //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF12 MDMA_GISR0 = 0x01 << 12 //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF13 MDMA_GISR0 = 0x01 << 13 //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF14 MDMA_GISR0 = 0x01 << 14 //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
	GIF15 MDMA_GISR0 = 0x01 << 15 //+ Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
)

const (
	GIF0n  = 0
	GIF1n  = 1
	GIF2n  = 2
	GIF3n  = 3
	GIF4n  = 4
	GIF5n  = 5
	GIF6n  = 6
	GIF7n  = 7
	GIF8n  = 8
	GIF9n  = 9
	GIF10n = 10
	GIF11n = 11
	GIF12n = 12
	GIF13n = 13
	GIF14n = 14
	GIF15n = 15
)

const (
	TEIF0  MDMA_C0ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF0 MDMA_C0ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF0 MDMA_C0ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF0  MDMA_C0ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF0  MDMA_C0ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA0  MDMA_C0ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF0n  = 0
	CTCIF0n = 1
	BRTIF0n = 2
	BTIF0n  = 3
	TCIF0n  = 4
	CRQA0n  = 16
)

const (
	CTEIF0  MDMA_C0IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF0 MDMA_C0IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF0 MDMA_C0IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF0  MDMA_C0IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF0 MDMA_C0IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF0n  = 0
	CCTCIF0n = 1
	CBRTIF0n = 2
	CBTIF0n  = 3
	CLTCIF0n = 4
)

const (
	TEA  MDMA_C0ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C0ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C0ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C0ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C0ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C0ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C0CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C0CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C0CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C0CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C0CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C0CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C0CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C0CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C0CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C0CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C0CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C0TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C0TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C0TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C0TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C0TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C0TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C0TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C0TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C0TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C0TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C0TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C0TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C0TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C0TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C0BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C0BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C0BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C0BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C0SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C0DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C0BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C0BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C0LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C0TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C0TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C0TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C0MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C0MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF1  MDMA_C1ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF1 MDMA_C1ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF1 MDMA_C1ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF1  MDMA_C1ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF1  MDMA_C1ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA1  MDMA_C1ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF1n  = 0
	CTCIF1n = 1
	BRTIF1n = 2
	BTIF1n  = 3
	TCIF1n  = 4
	CRQA1n  = 16
)

const (
	CTEIF1  MDMA_C1IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF1 MDMA_C1IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF1 MDMA_C1IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF1  MDMA_C1IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF1 MDMA_C1IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF1n  = 0
	CCTCIF1n = 1
	CBRTIF1n = 2
	CBTIF1n  = 3
	CLTCIF1n = 4
)

const (
	TEA  MDMA_C1ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C1ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C1ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C1ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C1ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C1ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C1CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C1CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C1CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C1CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C1CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C1CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C1CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C1CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C1CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C1CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C1CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C1TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C1TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C1TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C1TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C1TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C1TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C1TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C1TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C1TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C1TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C1TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C1TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C1TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C1TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C1BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C1BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C1BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C1BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C1SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C1DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C1BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C1BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C1LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C1TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C1TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C1TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C1MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C1MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF2  MDMA_C2ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF2 MDMA_C2ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF2 MDMA_C2ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF2  MDMA_C2ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF2  MDMA_C2ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA2  MDMA_C2ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF2n  = 0
	CTCIF2n = 1
	BRTIF2n = 2
	BTIF2n  = 3
	TCIF2n  = 4
	CRQA2n  = 16
)

const (
	CTEIF2  MDMA_C2IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF2 MDMA_C2IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF2 MDMA_C2IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF2  MDMA_C2IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF2 MDMA_C2IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF2n  = 0
	CCTCIF2n = 1
	CBRTIF2n = 2
	CBTIF2n  = 3
	CLTCIF2n = 4
)

const (
	TEA  MDMA_C2ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C2ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C2ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C2ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C2ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C2ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C2CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C2CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C2CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C2CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C2CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C2CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C2CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C2CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C2CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C2CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C2CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C2TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C2TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C2TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C2TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C2TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C2TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C2TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C2TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C2TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C2TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C2TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C2TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C2TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C2TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C2BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C2BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C2BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C2BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C2SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C2DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C2BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C2BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C2LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C2TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C2TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C2TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C2MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C2MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF3  MDMA_C3ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF3 MDMA_C3ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF3 MDMA_C3ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF3  MDMA_C3ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF3  MDMA_C3ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA3  MDMA_C3ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF3n  = 0
	CTCIF3n = 1
	BRTIF3n = 2
	BTIF3n  = 3
	TCIF3n  = 4
	CRQA3n  = 16
)

const (
	CTEIF3  MDMA_C3IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF3 MDMA_C3IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF3 MDMA_C3IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF3  MDMA_C3IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF3 MDMA_C3IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF3n  = 0
	CCTCIF3n = 1
	CBRTIF3n = 2
	CBTIF3n  = 3
	CLTCIF3n = 4
)

const (
	TEA  MDMA_C3ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C3ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C3ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C3ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C3ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C3ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C3CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C3CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C3CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C3CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C3CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C3CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C3CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C3CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C3CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C3CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C3CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C3TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C3TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C3TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C3TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C3TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C3TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C3TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C3TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C3TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C3TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C3TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C3TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C3TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C3TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C3BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C3BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C3BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C3BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C3SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C3DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C3BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C3BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C3LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C3TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C3TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C3TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C3MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C3MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF4  MDMA_C4ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF4 MDMA_C4ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF4 MDMA_C4ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF4  MDMA_C4ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF4  MDMA_C4ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA4  MDMA_C4ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF4n  = 0
	CTCIF4n = 1
	BRTIF4n = 2
	BTIF4n  = 3
	TCIF4n  = 4
	CRQA4n  = 16
)

const (
	CTEIF4  MDMA_C4IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF4 MDMA_C4IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF4 MDMA_C4IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF4  MDMA_C4IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF4 MDMA_C4IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF4n  = 0
	CCTCIF4n = 1
	CBRTIF4n = 2
	CBTIF4n  = 3
	CLTCIF4n = 4
)

const (
	TEA  MDMA_C4ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C4ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C4ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C4ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C4ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C4ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C4CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C4CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C4CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C4CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C4CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C4CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C4CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C4CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C4CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C4CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C4CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C4TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C4TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C4TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C4TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C4TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C4TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C4TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C4TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C4TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C4TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C4TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C4TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C4TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C4TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C4BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C4BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C4BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C4BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C4SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C4DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C4BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C4BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C4LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C4TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C4TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C4TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C4MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C4MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF5  MDMA_C5ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF5 MDMA_C5ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF5 MDMA_C5ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF5  MDMA_C5ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF5  MDMA_C5ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA5  MDMA_C5ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF5n  = 0
	CTCIF5n = 1
	BRTIF5n = 2
	BTIF5n  = 3
	TCIF5n  = 4
	CRQA5n  = 16
)

const (
	CTEIF5  MDMA_C5IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF5 MDMA_C5IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF5 MDMA_C5IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF5  MDMA_C5IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF5 MDMA_C5IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF5n  = 0
	CCTCIF5n = 1
	CBRTIF5n = 2
	CBTIF5n  = 3
	CLTCIF5n = 4
)

const (
	TEA  MDMA_C5ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C5ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C5ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C5ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C5ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C5ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C5CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C5CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C5CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C5CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C5CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C5CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C5CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C5CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C5CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C5CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C5CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C5TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C5TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C5TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C5TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C5TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C5TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C5TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C5TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C5TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C5TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C5TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C5TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C5TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C5TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C5BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C5BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C5BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C5BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C5SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C5DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C5BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C5BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C5LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C5TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C5TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C5TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C5MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C5MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF6  MDMA_C6ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF6 MDMA_C6ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF6 MDMA_C6ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF6  MDMA_C6ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF6  MDMA_C6ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA6  MDMA_C6ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF6n  = 0
	CTCIF6n = 1
	BRTIF6n = 2
	BTIF6n  = 3
	TCIF6n  = 4
	CRQA6n  = 16
)

const (
	CTEIF6  MDMA_C6IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF6 MDMA_C6IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF6 MDMA_C6IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF6  MDMA_C6IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF6 MDMA_C6IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF6n  = 0
	CCTCIF6n = 1
	CBRTIF6n = 2
	CBTIF6n  = 3
	CLTCIF6n = 4
)

const (
	TEA  MDMA_C6ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C6ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C6ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C6ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C6ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C6ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C6CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C6CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C6CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C6CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C6CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C6CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C6CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C6CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C6CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C6CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C6CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C6TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C6TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C6TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C6TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C6TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C6TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C6TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C6TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C6TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C6TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C6TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C6TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C6TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C6TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C6BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C6BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C6BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C6BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C6SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C6DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C6BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C6BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C6LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C6TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C6TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C6TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C6MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C6MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF7  MDMA_C7ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF7 MDMA_C7ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF7 MDMA_C7ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF7  MDMA_C7ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF7  MDMA_C7ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA7  MDMA_C7ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF7n  = 0
	CTCIF7n = 1
	BRTIF7n = 2
	BTIF7n  = 3
	TCIF7n  = 4
	CRQA7n  = 16
)

const (
	CTEIF7  MDMA_C7IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF7 MDMA_C7IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF7 MDMA_C7IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF7  MDMA_C7IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF7 MDMA_C7IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF7n  = 0
	CCTCIF7n = 1
	CBRTIF7n = 2
	CBTIF7n  = 3
	CLTCIF7n = 4
)

const (
	TEA  MDMA_C7ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C7ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C7ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C7ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C7ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C7ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C7CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C7CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C7CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C7CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C7CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C7CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C7CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C7CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C7CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C7CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C7CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C7TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C7TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C7TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C7TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C7TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C7TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C7TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C7TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C7TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C7TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C7TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C7TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C7TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C7TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C7BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C7BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C7BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C7BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C7SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C7DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C7BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C7BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C7LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C7TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C7TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C7TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C7MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C7MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF8  MDMA_C8ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF8 MDMA_C8ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF8 MDMA_C8ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF8  MDMA_C8ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF8  MDMA_C8ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA8  MDMA_C8ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF8n  = 0
	CTCIF8n = 1
	BRTIF8n = 2
	BTIF8n  = 3
	TCIF8n  = 4
	CRQA8n  = 16
)

const (
	CTEIF8  MDMA_C8IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF8 MDMA_C8IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF8 MDMA_C8IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF8  MDMA_C8IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF8 MDMA_C8IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF8n  = 0
	CCTCIF8n = 1
	CBRTIF8n = 2
	CBTIF8n  = 3
	CLTCIF8n = 4
)

const (
	TEA  MDMA_C8ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C8ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C8ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C8ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C8ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C8ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C8CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C8CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C8CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C8CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C8CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C8CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C8CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C8CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C8CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C8CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C8CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C8TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C8TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C8TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C8TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C8TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C8TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C8TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C8TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C8TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C8TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C8TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C8TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C8TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C8TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C8BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C8BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C8BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C8BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C8SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C8DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C8BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C8BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C8LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C8TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C8TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C8TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C8MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C8MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF9  MDMA_C9ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF9 MDMA_C9ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF9 MDMA_C9ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF9  MDMA_C9ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF9  MDMA_C9ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA9  MDMA_C9ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF9n  = 0
	CTCIF9n = 1
	BRTIF9n = 2
	BTIF9n  = 3
	TCIF9n  = 4
	CRQA9n  = 16
)

const (
	CTEIF9  MDMA_C9IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF9 MDMA_C9IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF9 MDMA_C9IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF9  MDMA_C9IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF9 MDMA_C9IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF9n  = 0
	CCTCIF9n = 1
	CBRTIF9n = 2
	CBTIF9n  = 3
	CLTCIF9n = 4
)

const (
	TEA  MDMA_C9ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C9ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C9ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C9ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C9ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C9ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C9CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C9CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C9CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C9CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C9CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C9CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C9CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C9CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C9CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C9CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C9CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C9TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C9TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C9TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C9TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C9TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C9TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C9TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C9TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C9TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C9TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C9TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C9TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C9TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C9TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C9BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C9BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C9BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C9BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C9SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C9DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C9BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C9BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C9LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C9TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C9TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C9TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C9MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C9MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF10  MDMA_C10ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF10 MDMA_C10ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF10 MDMA_C10ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF10  MDMA_C10ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF10  MDMA_C10ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA10  MDMA_C10ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF10n  = 0
	CTCIF10n = 1
	BRTIF10n = 2
	BTIF10n  = 3
	TCIF10n  = 4
	CRQA10n  = 16
)

const (
	CTEIF10  MDMA_C10IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF10 MDMA_C10IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF10 MDMA_C10IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF10  MDMA_C10IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF10 MDMA_C10IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF10n  = 0
	CCTCIF10n = 1
	CBRTIF10n = 2
	CBTIF10n  = 3
	CLTCIF10n = 4
)

const (
	TEA  MDMA_C10ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C10ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C10ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C10ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C10ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C10ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C10CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C10CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C10CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C10CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C10CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C10CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C10CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C10CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C10CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C10CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C10CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C10TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C10TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C10TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C10TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C10TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C10TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C10TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C10TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C10TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C10TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C10TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C10TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C10TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C10TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C10BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C10BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C10BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C10BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C10SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C10DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C10BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C10BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C10LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C10TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C10TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C10TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C10MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C10MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF11  MDMA_C11ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF11 MDMA_C11ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF11 MDMA_C11ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF11  MDMA_C11ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF11  MDMA_C11ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA11  MDMA_C11ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF11n  = 0
	CTCIF11n = 1
	BRTIF11n = 2
	BTIF11n  = 3
	TCIF11n  = 4
	CRQA11n  = 16
)

const (
	CTEIF11  MDMA_C11IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF11 MDMA_C11IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF11 MDMA_C11IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF11  MDMA_C11IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF11 MDMA_C11IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF11n  = 0
	CCTCIF11n = 1
	CBRTIF11n = 2
	CBTIF11n  = 3
	CLTCIF11n = 4
)

const (
	TEA  MDMA_C11ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C11ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C11ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C11ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C11ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C11ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C11CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C11CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C11CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C11CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C11CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C11CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C11CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C11CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C11CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C11CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C11CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C11TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C11TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C11TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C11TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C11TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C11TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C11TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C11TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C11TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C11TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C11TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C11TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C11TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C11TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C11BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C11BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C11BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C11BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C11SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C11DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C11BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C11BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C11LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C11TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C11TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C11TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C11MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C11MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF12  MDMA_C12ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF12 MDMA_C12ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF12 MDMA_C12ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF12  MDMA_C12ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF12  MDMA_C12ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA12  MDMA_C12ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF12n  = 0
	CTCIF12n = 1
	BRTIF12n = 2
	BTIF12n  = 3
	TCIF12n  = 4
	CRQA12n  = 16
)

const (
	CTEIF12  MDMA_C12IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF12 MDMA_C12IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF12 MDMA_C12IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF12  MDMA_C12IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF12 MDMA_C12IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF12n  = 0
	CCTCIF12n = 1
	CBRTIF12n = 2
	CBTIF12n  = 3
	CLTCIF12n = 4
)

const (
	TEA  MDMA_C12ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C12ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C12ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C12ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C12ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C12ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C12CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C12CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C12CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C12CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C12CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C12CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C12CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C12CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C12CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C12CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C12CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C12TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C12TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C12TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C12TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C12TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C12TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C12TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C12TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C12TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C12TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C12TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C12TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C12TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C12TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C12BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C12BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C12BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C12BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C12SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C12DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C12BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C12BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C12LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C12TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C12TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C12TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C12MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C12MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF13  MDMA_C13ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF13 MDMA_C13ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF13 MDMA_C13ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF13  MDMA_C13ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF13  MDMA_C13ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA13  MDMA_C13ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF13n  = 0
	CTCIF13n = 1
	BRTIF13n = 2
	BTIF13n  = 3
	TCIF13n  = 4
	CRQA13n  = 16
)

const (
	CTEIF13  MDMA_C13IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF13 MDMA_C13IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF13 MDMA_C13IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF13  MDMA_C13IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF13 MDMA_C13IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF13n  = 0
	CCTCIF13n = 1
	CBRTIF13n = 2
	CBTIF13n  = 3
	CLTCIF13n = 4
)

const (
	TEA  MDMA_C13ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C13ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C13ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C13ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C13ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C13ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C13CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C13CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C13CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C13CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C13CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C13CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C13CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C13CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C13CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C13CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C13CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C13TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C13TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C13TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C13TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C13TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C13TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C13TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C13TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C13TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C13TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C13TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C13TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C13TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C13TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C13BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C13BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C13BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C13BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C13SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C13DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C13BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C13BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C13LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C13TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C13TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C13TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C13MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C13MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF14  MDMA_C14ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF14 MDMA_C14ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF14 MDMA_C14ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF14  MDMA_C14ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF14  MDMA_C14ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA14  MDMA_C14ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF14n  = 0
	CTCIF14n = 1
	BRTIF14n = 2
	BTIF14n  = 3
	TCIF14n  = 4
	CRQA14n  = 16
)

const (
	CTEIF14  MDMA_C14IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF14 MDMA_C14IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF14 MDMA_C14IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF14  MDMA_C14IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF14 MDMA_C14IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF14n  = 0
	CCTCIF14n = 1
	CBRTIF14n = 2
	CBTIF14n  = 3
	CLTCIF14n = 4
)

const (
	TEA  MDMA_C14ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C14ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C14ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C14ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C14ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C14ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C14CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C14CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C14CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C14CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C14CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C14CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C14CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C14CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C14CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C14CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C14CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C14TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C14TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C14TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C14TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C14TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C14TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C14TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C14TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C14TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C14TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C14TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C14TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C14TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C14TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C14BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C14BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C14BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C14BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C14SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C14DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C14BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C14BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C14LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C14TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C14TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C14TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C14MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C14MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)

const (
	TEIF15  MDMA_C15ISR = 0x01 << 0  //+ Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	CTCIF15 MDMA_C15ISR = 0x01 << 1  //+ Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	BRTIF15 MDMA_C15ISR = 0x01 << 2  //+ Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	BTIF15  MDMA_C15ISR = 0x01 << 3  //+ Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	TCIF15  MDMA_C15ISR = 0x01 << 4  //+ channel x buffer transfer complete
	CRQA15  MDMA_C15ISR = 0x01 << 16 //+ channel x request active flag
)

const (
	TEIF15n  = 0
	CTCIF15n = 1
	BRTIF15n = 2
	BTIF15n  = 3
	TCIF15n  = 4
	CRQA15n  = 16
)

const (
	CTEIF15  MDMA_C15IFCR = 0x01 << 0 //+ Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
	CCTCIF15 MDMA_C15IFCR = 0x01 << 1 //+ Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	CBRTIF15 MDMA_C15IFCR = 0x01 << 2 //+ Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	CBTIF15  MDMA_C15IFCR = 0x01 << 3 //+ Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	CLTCIF15 MDMA_C15IFCR = 0x01 << 4 //+ CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
)

const (
	CTEIF15n  = 0
	CCTCIF15n = 1
	CBRTIF15n = 2
	CBTIF15n  = 3
	CLTCIF15n = 4
)

const (
	TEA  MDMA_C15ESR = 0x7F << 0  //+ Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
	TED  MDMA_C15ESR = 0x01 << 7  //+ Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	TELD MDMA_C15ESR = 0x01 << 8  //+ Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	TEMD MDMA_C15ESR = 0x01 << 9  //+ Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	ASE  MDMA_C15ESR = 0x01 << 10 //+ Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	BSE  MDMA_C15ESR = 0x01 << 11 //+ Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
)

const (
	TEAn  = 0
	TEDn  = 7
	TELDn = 8
	TEMDn = 9
	ASEn  = 10
	BSEn  = 11
)

const (
	EN    MDMA_C15CR = 0x01 << 0  //+ channel enable
	TEIE  MDMA_C15CR = 0x01 << 1  //+ Transfer error interrupt enable This bit is set and cleared by software.
	CTCIE MDMA_C15CR = 0x01 << 2  //+ Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	BRTIE MDMA_C15CR = 0x01 << 3  //+ Block Repeat transfer interrupt enable This bit is set and cleared by software.
	BTIE  MDMA_C15CR = 0x01 << 4  //+ Block Transfer interrupt enable This bit is set and cleared by software.
	TCIE  MDMA_C15CR = 0x01 << 5  //+ buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	PL    MDMA_C15CR = 0x03 << 6  //+ Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	BEX   MDMA_C15CR = 0x01 << 12 //+ byte Endianness exchange
	HEX   MDMA_C15CR = 0x01 << 13 //+ Half word Endianes exchange
	WEX   MDMA_C15CR = 0x01 << 14 //+ Word Endianness exchange
	SWRQ  MDMA_C15CR = 0x01 << 16 //+ SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
)

const (
	ENn    = 0
	TEIEn  = 1
	CTCIEn = 2
	BRTIEn = 3
	BTIEn  = 4
	TCIEn  = 5
	PLn    = 6
	BEXn   = 12
	HEXn   = 13
	WEXn   = 14
	SWRQn  = 16
)

const (
	SINC   MDMA_C15TCR = 0x03 << 0  //+ Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
	DINC   MDMA_C15TCR = 0x03 << 2  //+ Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	SSIZE  MDMA_C15TCR = 0x03 << 4  //+ Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	DSIZE  MDMA_C15TCR = 0x03 << 6  //+ Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	SINCOS MDMA_C15TCR = 0x03 << 8  //+ source increment offset size
	DINCOS MDMA_C15TCR = 0x03 << 10 //+ Destination increment offset
	SBURST MDMA_C15TCR = 0x07 << 12 //+ source burst transfer configuration
	DBURST MDMA_C15TCR = 0x07 << 15 //+ Destination burst transfer configuration
	TLEN   MDMA_C15TCR = 0x7F << 18 //+ buffer transfer lengh
	PKE    MDMA_C15TCR = 0x01 << 25 //+ PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	PAM    MDMA_C15TCR = 0x03 << 26 //+ Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	TRGM   MDMA_C15TCR = 0x03 << 28 //+ Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	SWRM   MDMA_C15TCR = 0x01 << 30 //+ SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	BWM    MDMA_C15TCR = 0x01 << 31 //+ Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
)

const (
	SINCn   = 0
	DINCn   = 2
	SSIZEn  = 4
	DSIZEn  = 6
	SINCOSn = 8
	DINCOSn = 10
	SBURSTn = 12
	DBURSTn = 15
	TLENn   = 18
	PKEn    = 25
	PAMn    = 26
	TRGMn   = 28
	SWRMn   = 30
	BWMn    = 31
)

const (
	BNDT  MDMA_C15BNDTR = 0x1FFFF << 0 //+ block number of data to transfer
	BRSUM MDMA_C15BNDTR = 0x01 << 18   //+ Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	BRDUM MDMA_C15BNDTR = 0x01 << 19   //+ Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	BRC   MDMA_C15BNDTR = 0xFFF << 20  //+ Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
)

const (
	BNDTn  = 0
	BRSUMn = 18
	BRDUMn = 19
	BRCn   = 20
)

const (
	SAR MDMA_C15SAR = 0xFFFFFFFF << 0 //+ source adr base
)

const (
	SARn = 0
)

const (
	DAR MDMA_C15DAR = 0xFFFFFFFF << 0 //+ Destination adr base
)

const (
	DARn = 0
)

const (
	SUV MDMA_C15BRUR = 0xFFFF << 0  //+ source adresse update value
	DUV MDMA_C15BRUR = 0xFFFF << 16 //+ destination address update
)

const (
	SUVn = 0
	DUVn = 16
)

const (
	LAR MDMA_C15LAR = 0xFFFFFFFF << 0 //+ Link address register
)

const (
	LARn = 0
)

const (
	TSEL MDMA_C15TBR = 0x3F << 0  //+ Trigger selection
	SBUS MDMA_C15TBR = 0x01 << 16 //+ Source BUS select This bit is protected and can be written only if EN is 0.
	DBUS MDMA_C15TBR = 0x01 << 17 //+ Destination BUS slect This bit is protected and can be written only if EN is 0.
)

const (
	TSELn = 0
	SBUSn = 16
	DBUSn = 17
)

const (
	MAR MDMA_C15MAR = 0xFFFFFFFF << 0 //+ Mask address
)

const (
	MARn = 0
)

const (
	MDR MDMA_C15MDR = 0xFFFFFFFF << 0 //+ Mask data
)

const (
	MDRn = 0
)
