// Code generated by svdxgen; DO NOT EDIT.

//go:build stm32f407

// Package otg_hs_device provides access to the registers of the OTG_HS_DEVICE peripheral.
//
// Instances:
//
//	OTG_HS_DEVICE  OTG_HS_DEVICE_BASE  -  -  USB on the go high speed
//
// Registers:
//
//	0x000 32  OTG_HS_DCFG          OTG_HS device configuration register
//	0x004 32  OTG_HS_DCTL          OTG_HS device control register
//	0x008 32  OTG_HS_DSTS          OTG_HS device status register
//	0x010 32  OTG_HS_DIEPMSK       OTG_HS device IN endpoint common interrupt mask register
//	0x014 32  OTG_HS_DOEPMSK       OTG_HS device OUT endpoint common interrupt mask register
//	0x018 32  OTG_HS_DAINT         OTG_HS device all endpoints interrupt register
//	0x01C 32  OTG_HS_DAINTMSK      OTG_HS all endpoints interrupt mask register
//	0x028 32  OTG_HS_DVBUSDIS      OTG_HS device VBUS discharge time register
//	0x02C 32  OTG_HS_DVBUSPULSE    OTG_HS device VBUS pulsing time register
//	0x030 32  OTG_HS_DTHRCTL       OTG_HS Device threshold control register
//	0x034 32  OTG_HS_DIEPEMPMSK    OTG_HS device IN endpoint FIFO empty interrupt mask register
//	0x038 32  OTG_HS_DEACHINT      OTG_HS device each endpoint interrupt register
//	0x03C 32  OTG_HS_DEACHINTMSK   OTG_HS device each endpoint interrupt register mask
//	0x040 32  OTG_HS_DIEPEACHMSK1  OTG_HS device each in endpoint-1 interrupt register
//	0x080 32  OTG_HS_DOEPEACHMSK1  OTG_HS device each OUT endpoint-1 interrupt register
//	0x100 32  OTG_HS_DIEPCTL0      OTG device endpoint-0 control register
//	0x108 32  OTG_HS_DIEPINT0      OTG device endpoint-0 interrupt register
//	0x110 32  OTG_HS_DIEPTSIZ0     OTG_HS device IN endpoint 0 transfer size register
//	0x114 32  OTG_HS_DIEPDMA1      OTG_HS device endpoint-1 DMA address register
//	0x118 32  OTG_HS_DTXFSTS0      OTG_HS device IN endpoint transmit FIFO status register
//	0x120 32  OTG_HS_DIEPCTL1      OTG device endpoint-1 control register
//	0x128 32  OTG_HS_DIEPINT1      OTG device endpoint-1 interrupt register
//	0x130 32  OTG_HS_DIEPTSIZ1     OTG_HS device endpoint transfer size register
//	0x134 32  OTG_HS_DIEPDMA2      OTG_HS device endpoint-2 DMA address register
//	0x138 32  OTG_HS_DTXFSTS1      OTG_HS device IN endpoint transmit FIFO status register
//	0x140 32  OTG_HS_DIEPCTL2      OTG device endpoint-2 control register
//	0x148 32  OTG_HS_DIEPINT2      OTG device endpoint-2 interrupt register
//	0x150 32  OTG_HS_DIEPTSIZ2     OTG_HS device endpoint transfer size register
//	0x154 32  OTG_HS_DIEPDMA3      OTG_HS device endpoint-3 DMA address register
//	0x158 32  OTG_HS_DTXFSTS2      OTG_HS device IN endpoint transmit FIFO status register
//	0x160 32  OTG_HS_DIEPCTL3      OTG device endpoint-3 control register
//	0x168 32  OTG_HS_DIEPINT3      OTG device endpoint-3 interrupt register
//	0x170 32  OTG_HS_DIEPTSIZ3     OTG_HS device endpoint transfer size register
//	0x174 32  OTG_HS_DIEPDMA4      OTG_HS device endpoint-4 DMA address register
//	0x178 32  OTG_HS_DTXFSTS3      OTG_HS device IN endpoint transmit FIFO status register
//	0x180 32  OTG_HS_DIEPCTL4      OTG device endpoint-4 control register
//	0x188 32  OTG_HS_DIEPINT4      OTG device endpoint-4 interrupt register
//	0x190 32  OTG_HS_DIEPTSIZ4     OTG_HS device endpoint transfer size register
//	0x194 32  OTG_HS_DIEPDMA5      OTG_HS device endpoint-5 DMA address register
//	0x198 32  OTG_HS_DTXFSTS4      OTG_HS device IN endpoint transmit FIFO status register
//	0x1A0 32  OTG_HS_DIEPCTL5      OTG device endpoint-5 control register
//	0x1A8 32  OTG_HS_DIEPINT5      OTG device endpoint-5 interrupt register
//	0x1B0 32  OTG_HS_DIEPTSIZ5     OTG_HS device endpoint transfer size register
//	0x1B8 32  OTG_HS_DTXFSTS5      OTG_HS device IN endpoint transmit FIFO status register
//	0x1C0 32  OTG_HS_DIEPCTL6      OTG device endpoint-6 control register
//	0x1C8 32  OTG_HS_DIEPINT6      OTG device endpoint-6 interrupt register
//	0x1E0 32  OTG_HS_DIEPCTL7      OTG device endpoint-7 control register
//	0x1E8 32  OTG_HS_DIEPINT7      OTG device endpoint-7 interrupt register
//	0x300 32  OTG_HS_DOEPCTL0      OTG_HS device control OUT endpoint 0 control register
//	0x308 32  OTG_HS_DOEPINT0      OTG_HS device endpoint-0 interrupt register
//	0x310 32  OTG_HS_DOEPTSIZ0     OTG_HS device endpoint-1 transfer size register
//	0x320 32  OTG_HS_DOEPCTL1      OTG device endpoint-1 control register
//	0x328 32  OTG_HS_DOEPINT1      OTG_HS device endpoint-1 interrupt register
//	0x330 32  OTG_HS_DOEPTSIZ1     OTG_HS device endpoint-2 transfer size register
//	0x340 32  OTG_HS_DOEPCTL2      OTG device endpoint-2 control register
//	0x348 32  OTG_HS_DOEPINT2      OTG_HS device endpoint-2 interrupt register
//	0x350 32  OTG_HS_DOEPTSIZ2     OTG_HS device endpoint-3 transfer size register
//	0x360 32  OTG_HS_DOEPCTL3      OTG device endpoint-3 control register
//	0x368 32  OTG_HS_DOEPINT3      OTG_HS device endpoint-3 interrupt register
//	0x370 32  OTG_HS_DOEPTSIZ3     OTG_HS device endpoint-4 transfer size register
//	0x388 32  OTG_HS_DOEPINT4      OTG_HS device endpoint-4 interrupt register
//	0x390 32  OTG_HS_DOEPTSIZ4     OTG_HS device endpoint-5 transfer size register
//	0x3A8 32  OTG_HS_DOEPINT5      OTG_HS device endpoint-5 interrupt register
//	0x3C8 32  OTG_HS_DOEPINT6      OTG_HS device endpoint-6 interrupt register
//	0x3E8 32  OTG_HS_DOEPINT7      OTG_HS device endpoint-7 interrupt register
//
// Import:
//
//	github.com/embeddedgo/stm32/p/mmap
package otg_hs_device

const (
	DSPD      OTG_HS_DCFG = 0x03 << 0  //+ Device speed
	NZLSOHSK  OTG_HS_DCFG = 0x01 << 2  //+ Nonzero-length status OUT handshake
	DAD       OTG_HS_DCFG = 0x7F << 4  //+ Device address
	PFIVL     OTG_HS_DCFG = 0x03 << 11 //+ Periodic (micro)frame interval
	PERSCHIVL OTG_HS_DCFG = 0x03 << 24 //+ Periodic scheduling interval
)

const (
	DSPDn      = 0
	NZLSOHSKn  = 2
	DADn       = 4
	PFIVLn     = 11
	PERSCHIVLn = 24
)

const (
	RWUSIG   OTG_HS_DCTL = 0x01 << 0  //+ Remote wakeup signaling
	SDIS     OTG_HS_DCTL = 0x01 << 1  //+ Soft disconnect
	GINSTS   OTG_HS_DCTL = 0x01 << 2  //+ Global IN NAK status
	GONSTS   OTG_HS_DCTL = 0x01 << 3  //+ Global OUT NAK status
	TCTL     OTG_HS_DCTL = 0x07 << 4  //+ Test control
	SGINAK   OTG_HS_DCTL = 0x01 << 7  //+ Set global IN NAK
	CGINAK   OTG_HS_DCTL = 0x01 << 8  //+ Clear global IN NAK
	SGONAK   OTG_HS_DCTL = 0x01 << 9  //+ Set global OUT NAK
	CGONAK   OTG_HS_DCTL = 0x01 << 10 //+ Clear global OUT NAK
	POPRGDNE OTG_HS_DCTL = 0x01 << 11 //+ Power-on programming done
)

const (
	RWUSIGn   = 0
	SDISn     = 1
	GINSTSn   = 2
	GONSTSn   = 3
	TCTLn     = 4
	SGINAKn   = 7
	CGINAKn   = 8
	SGONAKn   = 9
	CGONAKn   = 10
	POPRGDNEn = 11
)

const (
	SUSPSTS OTG_HS_DSTS = 0x01 << 0   //+ Suspend status
	ENUMSPD OTG_HS_DSTS = 0x03 << 1   //+ Enumerated speed
	EERR    OTG_HS_DSTS = 0x01 << 3   //+ Erratic error
	FNSOF   OTG_HS_DSTS = 0x3FFF << 8 //+ Frame number of the received SOF
)

const (
	SUSPSTSn = 0
	ENUMSPDn = 1
	EERRn    = 3
	FNSOFn   = 8
)

const (
	XFRCM     OTG_HS_DIEPMSK = 0x01 << 0 //+ Transfer completed interrupt mask
	EPDM      OTG_HS_DIEPMSK = 0x01 << 1 //+ Endpoint disabled interrupt mask
	TOM       OTG_HS_DIEPMSK = 0x01 << 3 //+ Timeout condition mask (nonisochronous endpoints)
	ITTXFEMSK OTG_HS_DIEPMSK = 0x01 << 4 //+ IN token received when TxFIFO empty mask
	INEPNMM   OTG_HS_DIEPMSK = 0x01 << 5 //+ IN token received with EP mismatch mask
	INEPNEM   OTG_HS_DIEPMSK = 0x01 << 6 //+ IN endpoint NAK effective mask
	TXFURM    OTG_HS_DIEPMSK = 0x01 << 8 //+ FIFO underrun mask
	BIM       OTG_HS_DIEPMSK = 0x01 << 9 //+ BNA interrupt mask
)

const (
	XFRCMn     = 0
	EPDMn      = 1
	TOMn       = 3
	ITTXFEMSKn = 4
	INEPNMMn   = 5
	INEPNEMn   = 6
	TXFURMn    = 8
	BIMn       = 9
)

const (
	XFRCM   OTG_HS_DOEPMSK = 0x01 << 0 //+ Transfer completed interrupt mask
	EPDM    OTG_HS_DOEPMSK = 0x01 << 1 //+ Endpoint disabled interrupt mask
	STUPM   OTG_HS_DOEPMSK = 0x01 << 3 //+ SETUP phase done mask
	OTEPDM  OTG_HS_DOEPMSK = 0x01 << 4 //+ OUT token received when endpoint disabled mask
	B2BSTUP OTG_HS_DOEPMSK = 0x01 << 6 //+ Back-to-back SETUP packets received mask
	OPEM    OTG_HS_DOEPMSK = 0x01 << 8 //+ OUT packet error mask
	BOIM    OTG_HS_DOEPMSK = 0x01 << 9 //+ BNA interrupt mask
)

const (
	XFRCMn   = 0
	EPDMn    = 1
	STUPMn   = 3
	OTEPDMn  = 4
	B2BSTUPn = 6
	OPEMn    = 8
	BOIMn    = 9
)

const (
	IEPINT OTG_HS_DAINT = 0xFFFF << 0  //+ IN endpoint interrupt bits
	OEPINT OTG_HS_DAINT = 0xFFFF << 16 //+ OUT endpoint interrupt bits
)

const (
	IEPINTn = 0
	OEPINTn = 16
)

const (
	IEPM OTG_HS_DAINTMSK = 0xFFFF << 0  //+ IN EP interrupt mask bits
	OEPM OTG_HS_DAINTMSK = 0xFFFF << 16 //+ OUT EP interrupt mask bits
)

const (
	IEPMn = 0
	OEPMn = 16
)

const (
	VBUSDT OTG_HS_DVBUSDIS = 0xFFFF << 0 //+ Device VBUS discharge time
)

const (
	VBUSDTn = 0
)

const (
	DVBUSP OTG_HS_DVBUSPULSE = 0xFFF << 0 //+ Device VBUS pulsing time
)

const (
	DVBUSPn = 0
)

const (
	NONISOTHREN OTG_HS_DTHRCTL = 0x01 << 0   //+ Nonisochronous IN endpoints threshold enable
	ISOTHREN    OTG_HS_DTHRCTL = 0x01 << 1   //+ ISO IN endpoint threshold enable
	TXTHRLEN    OTG_HS_DTHRCTL = 0x1FF << 2  //+ Transmit threshold length
	RXTHREN     OTG_HS_DTHRCTL = 0x01 << 16  //+ Receive threshold enable
	RXTHRLEN    OTG_HS_DTHRCTL = 0x1FF << 17 //+ Receive threshold length
	ARPEN       OTG_HS_DTHRCTL = 0x01 << 27  //+ Arbiter parking enable
)

const (
	NONISOTHRENn = 0
	ISOTHRENn    = 1
	TXTHRLENn    = 2
	RXTHRENn     = 16
	RXTHRLENn    = 17
	ARPENn       = 27
)

const (
	INEPTXFEM OTG_HS_DIEPEMPMSK = 0xFFFF << 0 //+ IN EP Tx FIFO empty interrupt mask bits
)

const (
	INEPTXFEMn = 0
)

const (
	IEP1INT OTG_HS_DEACHINT = 0x01 << 1  //+ IN endpoint 1interrupt bit
	OEP1INT OTG_HS_DEACHINT = 0x01 << 17 //+ OUT endpoint 1 interrupt bit
)

const (
	IEP1INTn = 1
	OEP1INTn = 17
)

const (
	IEP1INTM OTG_HS_DEACHINTMSK = 0x01 << 1  //+ IN Endpoint 1 interrupt mask bit
	OEP1INTM OTG_HS_DEACHINTMSK = 0x01 << 17 //+ OUT Endpoint 1 interrupt mask bit
)

const (
	IEP1INTMn = 1
	OEP1INTMn = 17
)

const (
	XFRCM     OTG_HS_DIEPEACHMSK1 = 0x01 << 0  //+ Transfer completed interrupt mask
	EPDM      OTG_HS_DIEPEACHMSK1 = 0x01 << 1  //+ Endpoint disabled interrupt mask
	TOM       OTG_HS_DIEPEACHMSK1 = 0x01 << 3  //+ Timeout condition mask (nonisochronous endpoints)
	ITTXFEMSK OTG_HS_DIEPEACHMSK1 = 0x01 << 4  //+ IN token received when TxFIFO empty mask
	INEPNMM   OTG_HS_DIEPEACHMSK1 = 0x01 << 5  //+ IN token received with EP mismatch mask
	INEPNEM   OTG_HS_DIEPEACHMSK1 = 0x01 << 6  //+ IN endpoint NAK effective mask
	TXFURM    OTG_HS_DIEPEACHMSK1 = 0x01 << 8  //+ FIFO underrun mask
	BIM       OTG_HS_DIEPEACHMSK1 = 0x01 << 9  //+ BNA interrupt mask
	NAKM      OTG_HS_DIEPEACHMSK1 = 0x01 << 13 //+ NAK interrupt mask
)

const (
	XFRCMn     = 0
	EPDMn      = 1
	TOMn       = 3
	ITTXFEMSKn = 4
	INEPNMMn   = 5
	INEPNEMn   = 6
	TXFURMn    = 8
	BIMn       = 9
	NAKMn      = 13
)

const (
	XFRCM     OTG_HS_DOEPEACHMSK1 = 0x01 << 0  //+ Transfer completed interrupt mask
	EPDM      OTG_HS_DOEPEACHMSK1 = 0x01 << 1  //+ Endpoint disabled interrupt mask
	TOM       OTG_HS_DOEPEACHMSK1 = 0x01 << 3  //+ Timeout condition mask
	ITTXFEMSK OTG_HS_DOEPEACHMSK1 = 0x01 << 4  //+ IN token received when TxFIFO empty mask
	INEPNMM   OTG_HS_DOEPEACHMSK1 = 0x01 << 5  //+ IN token received with EP mismatch mask
	INEPNEM   OTG_HS_DOEPEACHMSK1 = 0x01 << 6  //+ IN endpoint NAK effective mask
	TXFURM    OTG_HS_DOEPEACHMSK1 = 0x01 << 8  //+ OUT packet error mask
	BIM       OTG_HS_DOEPEACHMSK1 = 0x01 << 9  //+ BNA interrupt mask
	BERRM     OTG_HS_DOEPEACHMSK1 = 0x01 << 12 //+ Bubble error interrupt mask
	NAKM      OTG_HS_DOEPEACHMSK1 = 0x01 << 13 //+ NAK interrupt mask
	NYETM     OTG_HS_DOEPEACHMSK1 = 0x01 << 14 //+ NYET interrupt mask
)

const (
	XFRCMn     = 0
	EPDMn      = 1
	TOMn       = 3
	ITTXFEMSKn = 4
	INEPNMMn   = 5
	INEPNEMn   = 6
	TXFURMn    = 8
	BIMn       = 9
	BERRMn     = 12
	NAKMn      = 13
	NYETMn     = 14
)

const (
	MPSIZ          OTG_HS_DIEPCTL0 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL0 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL0 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL0 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL0 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL0 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL0 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL0 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL0 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL0 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL0 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL0 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL0 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT0 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT0 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT0 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT0 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT0 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT0 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT0 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT0 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT0 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT0 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT0 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	XFRSIZ OTG_HS_DIEPTSIZ0 = 0x7F << 0  //+ Transfer size
	PKTCNT OTG_HS_DIEPTSIZ0 = 0x03 << 19 //+ Packet count
)

const (
	XFRSIZn = 0
	PKTCNTn = 19
)

const (
	DMAADDR OTG_HS_DIEPDMA1 = 0xFFFFFFFF << 0 //+ DMA address
)

const (
	DMAADDRn = 0
)

const (
	INEPTFSAV OTG_HS_DTXFSTS0 = 0xFFFF << 0 //+ IN endpoint TxFIFO space avail
)

const (
	INEPTFSAVn = 0
)

const (
	MPSIZ          OTG_HS_DIEPCTL1 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL1 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL1 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL1 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL1 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL1 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL1 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL1 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL1 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL1 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL1 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL1 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL1 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT1 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT1 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT1 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT1 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT1 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT1 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT1 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT1 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT1 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT1 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT1 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	XFRSIZ OTG_HS_DIEPTSIZ1 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT OTG_HS_DIEPTSIZ1 = 0x3FF << 19  //+ Packet count
	MCNT   OTG_HS_DIEPTSIZ1 = 0x03 << 29   //+ Multi count
)

const (
	XFRSIZn = 0
	PKTCNTn = 19
	MCNTn   = 29
)

const (
	DMAADDR OTG_HS_DIEPDMA2 = 0xFFFFFFFF << 0 //+ DMA address
)

const (
	DMAADDRn = 0
)

const (
	INEPTFSAV OTG_HS_DTXFSTS1 = 0xFFFF << 0 //+ IN endpoint TxFIFO space avail
)

const (
	INEPTFSAVn = 0
)

const (
	MPSIZ          OTG_HS_DIEPCTL2 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL2 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL2 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL2 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL2 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL2 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL2 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL2 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL2 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL2 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL2 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL2 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL2 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT2 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT2 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT2 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT2 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT2 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT2 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT2 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT2 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT2 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT2 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT2 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	XFRSIZ OTG_HS_DIEPTSIZ2 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT OTG_HS_DIEPTSIZ2 = 0x3FF << 19  //+ Packet count
	MCNT   OTG_HS_DIEPTSIZ2 = 0x03 << 29   //+ Multi count
)

const (
	XFRSIZn = 0
	PKTCNTn = 19
	MCNTn   = 29
)

const (
	DMAADDR OTG_HS_DIEPDMA3 = 0xFFFFFFFF << 0 //+ DMA address
)

const (
	DMAADDRn = 0
)

const (
	INEPTFSAV OTG_HS_DTXFSTS2 = 0xFFFF << 0 //+ IN endpoint TxFIFO space avail
)

const (
	INEPTFSAVn = 0
)

const (
	MPSIZ          OTG_HS_DIEPCTL3 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL3 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL3 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL3 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL3 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL3 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL3 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL3 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL3 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL3 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL3 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL3 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL3 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT3 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT3 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT3 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT3 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT3 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT3 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT3 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT3 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT3 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT3 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT3 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	XFRSIZ OTG_HS_DIEPTSIZ3 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT OTG_HS_DIEPTSIZ3 = 0x3FF << 19  //+ Packet count
	MCNT   OTG_HS_DIEPTSIZ3 = 0x03 << 29   //+ Multi count
)

const (
	XFRSIZn = 0
	PKTCNTn = 19
	MCNTn   = 29
)

const (
	DMAADDR OTG_HS_DIEPDMA4 = 0xFFFFFFFF << 0 //+ DMA address
)

const (
	DMAADDRn = 0
)

const (
	INEPTFSAV OTG_HS_DTXFSTS3 = 0xFFFF << 0 //+ IN endpoint TxFIFO space avail
)

const (
	INEPTFSAVn = 0
)

const (
	MPSIZ          OTG_HS_DIEPCTL4 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL4 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL4 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL4 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL4 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL4 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL4 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL4 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL4 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL4 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL4 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL4 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL4 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT4 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT4 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT4 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT4 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT4 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT4 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT4 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT4 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT4 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT4 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT4 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	XFRSIZ OTG_HS_DIEPTSIZ4 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT OTG_HS_DIEPTSIZ4 = 0x3FF << 19  //+ Packet count
	MCNT   OTG_HS_DIEPTSIZ4 = 0x03 << 29   //+ Multi count
)

const (
	XFRSIZn = 0
	PKTCNTn = 19
	MCNTn   = 29
)

const (
	DMAADDR OTG_HS_DIEPDMA5 = 0xFFFFFFFF << 0 //+ DMA address
)

const (
	DMAADDRn = 0
)

const (
	INEPTFSAV OTG_HS_DTXFSTS4 = 0xFFFF << 0 //+ IN endpoint TxFIFO space avail
)

const (
	INEPTFSAVn = 0
)

const (
	MPSIZ          OTG_HS_DIEPCTL5 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL5 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL5 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL5 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL5 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL5 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL5 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL5 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL5 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL5 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL5 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL5 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL5 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT5 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT5 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT5 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT5 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT5 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT5 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT5 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT5 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT5 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT5 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT5 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	XFRSIZ OTG_HS_DIEPTSIZ5 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT OTG_HS_DIEPTSIZ5 = 0x3FF << 19  //+ Packet count
	MCNT   OTG_HS_DIEPTSIZ5 = 0x03 << 29   //+ Multi count
)

const (
	XFRSIZn = 0
	PKTCNTn = 19
	MCNTn   = 29
)

const (
	INEPTFSAV OTG_HS_DTXFSTS5 = 0xFFFF << 0 //+ IN endpoint TxFIFO space avail
)

const (
	INEPTFSAVn = 0
)

const (
	MPSIZ          OTG_HS_DIEPCTL6 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL6 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL6 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL6 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL6 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL6 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL6 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL6 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL6 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL6 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL6 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL6 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL6 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT6 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT6 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT6 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT6 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT6 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT6 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT6 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT6 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT6 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT6 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT6 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	MPSIZ          OTG_HS_DIEPCTL7 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DIEPCTL7 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DIEPCTL7 = 0x01 << 16 //+ Even/odd frame
	NAKSTS         OTG_HS_DIEPCTL7 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DIEPCTL7 = 0x03 << 18 //+ Endpoint type
	Stall          OTG_HS_DIEPCTL7 = 0x01 << 21 //+ STALL handshake
	TXFNUM         OTG_HS_DIEPCTL7 = 0x0F << 22 //+ TxFIFO number
	CNAK           OTG_HS_DIEPCTL7 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DIEPCTL7 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DIEPCTL7 = 0x01 << 28 //+ Set DATA0 PID
	SODDFRM        OTG_HS_DIEPCTL7 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DIEPCTL7 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DIEPCTL7 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	Stalln          = 21
	TXFNUMn         = 22
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC       OTG_HS_DIEPINT7 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD     OTG_HS_DIEPINT7 = 0x01 << 1  //+ Endpoint disabled interrupt
	TOC        OTG_HS_DIEPINT7 = 0x01 << 3  //+ Timeout condition
	ITTXFE     OTG_HS_DIEPINT7 = 0x01 << 4  //+ IN token received when TxFIFO is empty
	INEPNE     OTG_HS_DIEPINT7 = 0x01 << 6  //+ IN endpoint NAK effective
	TXFE       OTG_HS_DIEPINT7 = 0x01 << 7  //+ Transmit FIFO empty
	TXFIFOUDRN OTG_HS_DIEPINT7 = 0x01 << 8  //+ Transmit Fifo Underrun
	BNA        OTG_HS_DIEPINT7 = 0x01 << 9  //+ Buffer not available interrupt
	PKTDRPSTS  OTG_HS_DIEPINT7 = 0x01 << 11 //+ Packet dropped status
	BERR       OTG_HS_DIEPINT7 = 0x01 << 12 //+ Babble error interrupt
	NAK        OTG_HS_DIEPINT7 = 0x01 << 13 //+ NAK interrupt
)

const (
	XFRCn       = 0
	EPDISDn     = 1
	TOCn        = 3
	ITTXFEn     = 4
	INEPNEn     = 6
	TXFEn       = 7
	TXFIFOUDRNn = 8
	BNAn        = 9
	PKTDRPSTSn  = 11
	BERRn       = 12
	NAKn        = 13
)

const (
	MPSIZ  OTG_HS_DOEPCTL0 = 0x03 << 0  //+ Maximum packet size
	USBAEP OTG_HS_DOEPCTL0 = 0x01 << 15 //+ USB active endpoint
	NAKSTS OTG_HS_DOEPCTL0 = 0x01 << 17 //+ NAK status
	EPTYP  OTG_HS_DOEPCTL0 = 0x03 << 18 //+ Endpoint type
	SNPM   OTG_HS_DOEPCTL0 = 0x01 << 20 //+ Snoop mode
	Stall  OTG_HS_DOEPCTL0 = 0x01 << 21 //+ STALL handshake
	CNAK   OTG_HS_DOEPCTL0 = 0x01 << 26 //+ Clear NAK
	SNAK   OTG_HS_DOEPCTL0 = 0x01 << 27 //+ Set NAK
	EPDIS  OTG_HS_DOEPCTL0 = 0x01 << 30 //+ Endpoint disable
	EPENA  OTG_HS_DOEPCTL0 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn  = 0
	USBAEPn = 15
	NAKSTSn = 17
	EPTYPn  = 18
	SNPMn   = 20
	Stalln  = 21
	CNAKn   = 26
	SNAKn   = 27
	EPDISn  = 30
	EPENAn  = 31
)

const (
	XFRC    OTG_HS_DOEPINT0 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT0 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT0 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT0 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT0 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT0 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRSIZ  OTG_HS_DOEPTSIZ0 = 0x7F << 0  //+ Transfer size
	PKTCNT  OTG_HS_DOEPTSIZ0 = 0x01 << 19 //+ Packet count
	STUPCNT OTG_HS_DOEPTSIZ0 = 0x03 << 29 //+ SETUP packet count
)

const (
	XFRSIZn  = 0
	PKTCNTn  = 19
	STUPCNTn = 29
)

const (
	MPSIZ          OTG_HS_DOEPCTL1 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DOEPCTL1 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DOEPCTL1 = 0x01 << 16 //+ Even odd frame/Endpoint data PID
	NAKSTS         OTG_HS_DOEPCTL1 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DOEPCTL1 = 0x03 << 18 //+ Endpoint type
	SNPM           OTG_HS_DOEPCTL1 = 0x01 << 20 //+ Snoop mode
	Stall          OTG_HS_DOEPCTL1 = 0x01 << 21 //+ STALL handshake
	CNAK           OTG_HS_DOEPCTL1 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DOEPCTL1 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DOEPCTL1 = 0x01 << 28 //+ Set DATA0 PID/Set even frame
	SODDFRM        OTG_HS_DOEPCTL1 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DOEPCTL1 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DOEPCTL1 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	SNPMn           = 20
	Stalln          = 21
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC    OTG_HS_DOEPINT1 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT1 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT1 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT1 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT1 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT1 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRSIZ         OTG_HS_DOEPTSIZ1 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT         OTG_HS_DOEPTSIZ1 = 0x3FF << 19  //+ Packet count
	RXDPID_STUPCNT OTG_HS_DOEPTSIZ1 = 0x03 << 29   //+ Received data PID/SETUP packet count
)

const (
	XFRSIZn         = 0
	PKTCNTn         = 19
	RXDPID_STUPCNTn = 29
)

const (
	MPSIZ          OTG_HS_DOEPCTL2 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DOEPCTL2 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DOEPCTL2 = 0x01 << 16 //+ Even odd frame/Endpoint data PID
	NAKSTS         OTG_HS_DOEPCTL2 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DOEPCTL2 = 0x03 << 18 //+ Endpoint type
	SNPM           OTG_HS_DOEPCTL2 = 0x01 << 20 //+ Snoop mode
	Stall          OTG_HS_DOEPCTL2 = 0x01 << 21 //+ STALL handshake
	CNAK           OTG_HS_DOEPCTL2 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DOEPCTL2 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DOEPCTL2 = 0x01 << 28 //+ Set DATA0 PID/Set even frame
	SODDFRM        OTG_HS_DOEPCTL2 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DOEPCTL2 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DOEPCTL2 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	SNPMn           = 20
	Stalln          = 21
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC    OTG_HS_DOEPINT2 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT2 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT2 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT2 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT2 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT2 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRSIZ         OTG_HS_DOEPTSIZ2 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT         OTG_HS_DOEPTSIZ2 = 0x3FF << 19  //+ Packet count
	RXDPID_STUPCNT OTG_HS_DOEPTSIZ2 = 0x03 << 29   //+ Received data PID/SETUP packet count
)

const (
	XFRSIZn         = 0
	PKTCNTn         = 19
	RXDPID_STUPCNTn = 29
)

const (
	MPSIZ          OTG_HS_DOEPCTL3 = 0x7FF << 0 //+ Maximum packet size
	USBAEP         OTG_HS_DOEPCTL3 = 0x01 << 15 //+ USB active endpoint
	EONUM_DPID     OTG_HS_DOEPCTL3 = 0x01 << 16 //+ Even odd frame/Endpoint data PID
	NAKSTS         OTG_HS_DOEPCTL3 = 0x01 << 17 //+ NAK status
	EPTYP          OTG_HS_DOEPCTL3 = 0x03 << 18 //+ Endpoint type
	SNPM           OTG_HS_DOEPCTL3 = 0x01 << 20 //+ Snoop mode
	Stall          OTG_HS_DOEPCTL3 = 0x01 << 21 //+ STALL handshake
	CNAK           OTG_HS_DOEPCTL3 = 0x01 << 26 //+ Clear NAK
	SNAK           OTG_HS_DOEPCTL3 = 0x01 << 27 //+ Set NAK
	SD0PID_SEVNFRM OTG_HS_DOEPCTL3 = 0x01 << 28 //+ Set DATA0 PID/Set even frame
	SODDFRM        OTG_HS_DOEPCTL3 = 0x01 << 29 //+ Set odd frame
	EPDIS          OTG_HS_DOEPCTL3 = 0x01 << 30 //+ Endpoint disable
	EPENA          OTG_HS_DOEPCTL3 = 0x01 << 31 //+ Endpoint enable
)

const (
	MPSIZn          = 0
	USBAEPn         = 15
	EONUM_DPIDn     = 16
	NAKSTSn         = 17
	EPTYPn          = 18
	SNPMn           = 20
	Stalln          = 21
	CNAKn           = 26
	SNAKn           = 27
	SD0PID_SEVNFRMn = 28
	SODDFRMn        = 29
	EPDISn          = 30
	EPENAn          = 31
)

const (
	XFRC    OTG_HS_DOEPINT3 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT3 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT3 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT3 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT3 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT3 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRSIZ         OTG_HS_DOEPTSIZ3 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT         OTG_HS_DOEPTSIZ3 = 0x3FF << 19  //+ Packet count
	RXDPID_STUPCNT OTG_HS_DOEPTSIZ3 = 0x03 << 29   //+ Received data PID/SETUP packet count
)

const (
	XFRSIZn         = 0
	PKTCNTn         = 19
	RXDPID_STUPCNTn = 29
)

const (
	XFRC    OTG_HS_DOEPINT4 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT4 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT4 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT4 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT4 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT4 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRSIZ         OTG_HS_DOEPTSIZ4 = 0x7FFFF << 0 //+ Transfer size
	PKTCNT         OTG_HS_DOEPTSIZ4 = 0x3FF << 19  //+ Packet count
	RXDPID_STUPCNT OTG_HS_DOEPTSIZ4 = 0x03 << 29   //+ Received data PID/SETUP packet count
)

const (
	XFRSIZn         = 0
	PKTCNTn         = 19
	RXDPID_STUPCNTn = 29
)

const (
	XFRC    OTG_HS_DOEPINT5 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT5 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT5 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT5 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT5 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT5 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRC    OTG_HS_DOEPINT6 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT6 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT6 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT6 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT6 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT6 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)

const (
	XFRC    OTG_HS_DOEPINT7 = 0x01 << 0  //+ Transfer completed interrupt
	EPDISD  OTG_HS_DOEPINT7 = 0x01 << 1  //+ Endpoint disabled interrupt
	STUP    OTG_HS_DOEPINT7 = 0x01 << 3  //+ SETUP phase done
	OTEPDIS OTG_HS_DOEPINT7 = 0x01 << 4  //+ OUT token received when endpoint disabled
	B2BSTUP OTG_HS_DOEPINT7 = 0x01 << 6  //+ Back-to-back SETUP packets received
	NYET    OTG_HS_DOEPINT7 = 0x01 << 14 //+ NYET interrupt
)

const (
	XFRCn    = 0
	EPDISDn  = 1
	STUPn    = 3
	OTEPDISn = 4
	B2BSTUPn = 6
	NYETn    = 14
)
