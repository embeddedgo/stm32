// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build stm32f412

// Package scb provides access to the registers of the SCB peripheral.
//
// Instances:
//
//	SCB  SCB_BASE  -  -  System control block
//
// Registers:
//
//	0x000 32  CPUID                 CPUID base register
//	0x004 32  ICSR                  Interrupt control and state register
//	0x008 32  VTOR                  Vector table offset register
//	0x00C 32  AIRCR                 Application interrupt and reset control register
//	0x010 32  SCR                   System control register
//	0x014 32  CCR                   Configuration and control register
//	0x018 32  SHPR1                 System handler priority registers
//	0x01C 32  SHPR2                 System handler priority registers
//	0x020 32  SHPR3                 System handler priority registers
//	0x024 32  SHCRS                 System handler control and state register
//	0x028 32  CFSR_UFSR_BFSR_MMFSR  Configurable fault status register
//	0x02C 32  HFSR                  Hard fault status register
//	0x034 32  MMFAR                 Memory management fault address register
//	0x038 32  BFAR                  Bus fault address register
//	0x03C 32  AFSR                  Auxiliary fault status register
//
// Import:
//
//	github.com/embeddedgo/stm32/p/mmap
package scb

const (
	Revision    CPUID = 0x0F << 0  //+ Revision number
	PartNo      CPUID = 0xFFF << 4 //+ Part number of the processor
	Constant    CPUID = 0x0F << 16 //+ Reads as 0xF
	Variant     CPUID = 0x0F << 20 //+ Variant number
	Implementer CPUID = 0xFF << 24 //+ Implementer code
)

const (
	Revisionn    = 0
	PartNon      = 4
	Constantn    = 16
	Variantn     = 20
	Implementern = 24
)

const (
	VECTACTIVE  ICSR = 0x1FF << 0 //+ Active vector
	RETTOBASE   ICSR = 0x01 << 11 //+ Return to base level
	VECTPENDING ICSR = 0x7F << 12 //+ Pending vector
	ISRPENDING  ICSR = 0x01 << 22 //+ Interrupt pending flag
	PENDSTCLR   ICSR = 0x01 << 25 //+ SysTick exception clear-pending bit
	PENDSTSET   ICSR = 0x01 << 26 //+ SysTick exception set-pending bit
	PENDSVCLR   ICSR = 0x01 << 27 //+ PendSV clear-pending bit
	PENDSVSET   ICSR = 0x01 << 28 //+ PendSV set-pending bit
	NMIPENDSET  ICSR = 0x01 << 31 //+ NMI set-pending bit.
)

const (
	VECTACTIVEn  = 0
	RETTOBASEn   = 11
	VECTPENDINGn = 12
	ISRPENDINGn  = 22
	PENDSTCLRn   = 25
	PENDSTSETn   = 26
	PENDSVCLRn   = 27
	PENDSVSETn   = 28
	NMIPENDSETn  = 31
)

const (
	TBLOFF VTOR = 0x1FFFFF << 9 //+ Vector table base offset field
)

const (
	TBLOFFn = 9
)

const (
	VECTRESET     AIRCR = 0x01 << 0    //+ VECTRESET
	VECTCLRACTIVE AIRCR = 0x01 << 1    //+ VECTCLRACTIVE
	SYSRESETREQ   AIRCR = 0x01 << 2    //+ SYSRESETREQ
	PRIGROUP      AIRCR = 0x07 << 8    //+ PRIGROUP
	ENDIANESS     AIRCR = 0x01 << 15   //+ ENDIANESS
	VECTKEYSTAT   AIRCR = 0xFFFF << 16 //+ Register key
)

const (
	VECTRESETn     = 0
	VECTCLRACTIVEn = 1
	SYSRESETREQn   = 2
	PRIGROUPn      = 8
	ENDIANESSn     = 15
	VECTKEYSTATn   = 16
)

const (
	SLEEPONEXIT SCR = 0x01 << 1 //+ SLEEPONEXIT
	SLEEPDEEP   SCR = 0x01 << 2 //+ SLEEPDEEP
	SEVEONPEND  SCR = 0x01 << 4 //+ Send Event on Pending bit
)

const (
	SLEEPONEXITn = 1
	SLEEPDEEPn   = 2
	SEVEONPENDn  = 4
)

const (
	NONBASETHRDENA CCR = 0x01 << 0 //+ Configures how the processor enters Thread mode
	USERSETMPEND   CCR = 0x01 << 1 //+ USERSETMPEND
	UNALIGN__TRP   CCR = 0x01 << 3 //+ UNALIGN_ TRP
	DIV_0_TRP      CCR = 0x01 << 4 //+ DIV_0_TRP
	BFHFNMIGN      CCR = 0x01 << 8 //+ BFHFNMIGN
	STKALIGN       CCR = 0x01 << 9 //+ STKALIGN
)

const (
	NONBASETHRDENAn = 0
	USERSETMPENDn   = 1
	UNALIGN__TRPn   = 3
	DIV_0_TRPn      = 4
	BFHFNMIGNn      = 8
	STKALIGNn       = 9
)

const (
	PRI_4 SHPR1 = 0xFF << 0  //+ Priority of system handler 4
	PRI_5 SHPR1 = 0xFF << 8  //+ Priority of system handler 5
	PRI_6 SHPR1 = 0xFF << 16 //+ Priority of system handler 6
)

const (
	PRI_4n = 0
	PRI_5n = 8
	PRI_6n = 16
)

const (
	PRI_11 SHPR2 = 0xFF << 24 //+ Priority of system handler 11
)

const (
	PRI_11n = 24
)

const (
	PRI_14 SHPR3 = 0xFF << 16 //+ Priority of system handler 14
	PRI_15 SHPR3 = 0xFF << 24 //+ Priority of system handler 15
)

const (
	PRI_14n = 16
	PRI_15n = 24
)

const (
	MEMFAULTACT    SHCRS = 0x01 << 0  //+ Memory management fault exception active bit
	BUSFAULTACT    SHCRS = 0x01 << 1  //+ Bus fault exception active bit
	USGFAULTACT    SHCRS = 0x01 << 3  //+ Usage fault exception active bit
	SVCALLACT      SHCRS = 0x01 << 7  //+ SVC call active bit
	MONITORACT     SHCRS = 0x01 << 8  //+ Debug monitor active bit
	PENDSVACT      SHCRS = 0x01 << 10 //+ PendSV exception active bit
	SYSTICKACT     SHCRS = 0x01 << 11 //+ SysTick exception active bit
	USGFAULTPENDED SHCRS = 0x01 << 12 //+ Usage fault exception pending bit
	MEMFAULTPENDED SHCRS = 0x01 << 13 //+ Memory management fault exception pending bit
	BUSFAULTPENDED SHCRS = 0x01 << 14 //+ Bus fault exception pending bit
	SVCALLPENDED   SHCRS = 0x01 << 15 //+ SVC call pending bit
	MEMFAULTENA    SHCRS = 0x01 << 16 //+ Memory management fault enable bit
	BUSFAULTENA    SHCRS = 0x01 << 17 //+ Bus fault enable bit
	USGFAULTENA    SHCRS = 0x01 << 18 //+ Usage fault enable bit
)

const (
	MEMFAULTACTn    = 0
	BUSFAULTACTn    = 1
	USGFAULTACTn    = 3
	SVCALLACTn      = 7
	MONITORACTn     = 8
	PENDSVACTn      = 10
	SYSTICKACTn     = 11
	USGFAULTPENDEDn = 12
	MEMFAULTPENDEDn = 13
	BUSFAULTPENDEDn = 14
	SVCALLPENDEDn   = 15
	MEMFAULTENAn    = 16
	BUSFAULTENAn    = 17
	USGFAULTENAn    = 18
)

const (
	IACCVIOL    CFSR_UFSR_BFSR_MMFSR = 0x01 << 1  //+ Instruction access violation flag
	MUNSTKERR   CFSR_UFSR_BFSR_MMFSR = 0x01 << 3  //+ Memory manager fault on unstacking for a return from exception
	MSTKERR     CFSR_UFSR_BFSR_MMFSR = 0x01 << 4  //+ Memory manager fault on stacking for exception entry.
	MLSPERR     CFSR_UFSR_BFSR_MMFSR = 0x01 << 5  //+ MLSPERR
	MMARVALID   CFSR_UFSR_BFSR_MMFSR = 0x01 << 7  //+ Memory Management Fault Address Register (MMAR) valid flag
	IBUSERR     CFSR_UFSR_BFSR_MMFSR = 0x01 << 8  //+ Instruction bus error
	PRECISERR   CFSR_UFSR_BFSR_MMFSR = 0x01 << 9  //+ Precise data bus error
	IMPRECISERR CFSR_UFSR_BFSR_MMFSR = 0x01 << 10 //+ Imprecise data bus error
	UNSTKERR    CFSR_UFSR_BFSR_MMFSR = 0x01 << 11 //+ Bus fault on unstacking for a return from exception
	STKERR      CFSR_UFSR_BFSR_MMFSR = 0x01 << 12 //+ Bus fault on stacking for exception entry
	LSPERR      CFSR_UFSR_BFSR_MMFSR = 0x01 << 13 //+ Bus fault on floating-point lazy state preservation
	BFARVALID   CFSR_UFSR_BFSR_MMFSR = 0x01 << 15 //+ Bus Fault Address Register (BFAR) valid flag
	UNDEFINSTR  CFSR_UFSR_BFSR_MMFSR = 0x01 << 16 //+ Undefined instruction usage fault
	INVSTATE    CFSR_UFSR_BFSR_MMFSR = 0x01 << 17 //+ Invalid state usage fault
	INVPC       CFSR_UFSR_BFSR_MMFSR = 0x01 << 18 //+ Invalid PC load usage fault
	NOCP        CFSR_UFSR_BFSR_MMFSR = 0x01 << 19 //+ No coprocessor usage fault.
	UNALIGNED   CFSR_UFSR_BFSR_MMFSR = 0x01 << 24 //+ Unaligned access usage fault
	DIVBYZERO   CFSR_UFSR_BFSR_MMFSR = 0x01 << 25 //+ Divide by zero usage fault
)

const (
	IACCVIOLn    = 1
	MUNSTKERRn   = 3
	MSTKERRn     = 4
	MLSPERRn     = 5
	MMARVALIDn   = 7
	IBUSERRn     = 8
	PRECISERRn   = 9
	IMPRECISERRn = 10
	UNSTKERRn    = 11
	STKERRn      = 12
	LSPERRn      = 13
	BFARVALIDn   = 15
	UNDEFINSTRn  = 16
	INVSTATEn    = 17
	INVPCn       = 18
	NOCPn        = 19
	UNALIGNEDn   = 24
	DIVBYZEROn   = 25
)

const (
	VECTTBL  HFSR = 0x01 << 1  //+ Vector table hard fault
	FORCED   HFSR = 0x01 << 30 //+ Forced hard fault
	DEBUG_VT HFSR = 0x01 << 31 //+ Reserved for Debug use
)

const (
	VECTTBLn  = 1
	FORCEDn   = 30
	DEBUG_VTn = 31
)

const (
	MMFAR MMFAR = 0xFFFFFFFF << 0 //+ Memory management fault address
)

const (
	MMFARn = 0
)

const (
	BFAR BFAR = 0xFFFFFFFF << 0 //+ Bus fault address
)

const (
	BFARn = 0
)

const (
	IMPDEF AFSR = 0xFFFFFFFF << 0 //+ Implementation defined
)

const (
	IMPDEFn = 0
)
