// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

// +build stm32g471xx

// Package rcc provides access to the registers of the RCC peripheral.
//
// Instances:
//  RCC  RCC_BASE  -  RCC  Reset and clock control
// Registers:
//  0x000 32  CR          Clock control register
//  0x004 32  ICSCR       Internal clock sources calibration register
//  0x008 32  CFGR        Clock configuration register
//  0x00C 32  PLLSYSCFGR  PLL configuration register
//  0x018 32  CIER        Clock interrupt enable register
//  0x01C 32  CIFR        Clock interrupt flag register
//  0x020 32  CICR        Clock interrupt clear register
//  0x028 32  AHB1RSTR    AHB1 peripheral reset register
//  0x02C 32  AHB2RSTR    AHB2 peripheral reset register
//  0x030 32  AHB3RSTR    AHB3 peripheral reset register
//  0x038 32  APB1RSTR1   APB1 peripheral reset register 1
//  0x03C 32  APB1RSTR2   APB1 peripheral reset register 2
//  0x040 32  APB2RSTR    APB2 peripheral reset register
//  0x048 32  AHB1ENR     AHB1 peripheral clock enable register
//  0x04C 32  AHB2ENR     AHB2 peripheral clock enable register
//  0x050 32  AHB3ENR     AHB3 peripheral clock enable register
//  0x058 32  APB1ENR1    APB1ENR1
//  0x05C 32  APB1ENR2    APB1 peripheral clock enable register 2
//  0x060 32  APB2ENR     APB2ENR
//  0x068 32  AHB1SMENR   AHB1 peripheral clocks enable in Sleep and Stop modes register
//  0x06C 32  AHB2SMENR   AHB2 peripheral clocks enable in Sleep and Stop modes register
//  0x070 32  AHB3SMENR   AHB3 peripheral clocks enable in Sleep and Stop modes register
//  0x078 32  APB1SMENR1  APB1SMENR1
//  0x07C 32  APB1SMENR2  APB1 peripheral clocks enable in Sleep and Stop modes register 2
//  0x080 32  APB2SMENR   APB2SMENR
//  0x088 32  CCIPR1      CCIPR
//  0x090 32  BDCR        BDCR
//  0x094 32  CSR         CSR
//  0x098 32  CRRCR       Clock recovery RC register
//  0x09C 32  CCIPR2      Peripherals independent clock configuration register
// Import:
//  github.com/embeddedgo/stm32/p/mmap
package rcc

const (
	HSION     CR = 0x01 << 8  //+ HSI clock enable
	HSIKERON  CR = 0x01 << 9  //+ HSI always enable for peripheral kernels
	HSIRDY    CR = 0x01 << 10 //+ HSI clock ready flag
	HSEON     CR = 0x01 << 16 //+ HSE clock enable
	HSERDY    CR = 0x01 << 17 //+ HSE clock ready flag
	HSEBYP    CR = 0x01 << 18 //+ HSE crystal oscillator bypass
	HSECSSON  CR = 0x01 << 19 //+ Clock security system enable
	PLLSYSON  CR = 0x01 << 24 //+ Main PLL enable
	PLLSYSRDY CR = 0x01 << 25 //+ Main PLL clock ready flag
)

const (
	HSIONn     = 8
	HSIKERONn  = 9
	HSIRDYn    = 10
	HSEONn     = 16
	HSERDYn    = 17
	HSEBYPn    = 18
	HSECSSONn  = 19
	PLLSYSONn  = 24
	PLLSYSRDYn = 25
)

const (
	HSICAL0 ICSCR = 0xFF << 16 //+ Internal High Speed clock Calibration
	HSITRIM ICSCR = 0x7F << 24 //+ Internal High Speed clock trimming
)

const (
	HSICAL0n = 16
	HSITRIMn = 24
)

const (
	SW     CFGR = 0x03 << 0  //+ System clock switch
	SWS    CFGR = 0x03 << 2  //+ System clock switch status
	HPRE   CFGR = 0x0F << 4  //+ AHB prescaler
	PPRE1  CFGR = 0x07 << 8  //+ PB low-speed prescaler (APB1)
	PPRE2  CFGR = 0x07 << 11 //+ APB high-speed prescaler (APB2)
	MCOSEL CFGR = 0x0F << 24 //+ Microcontroller clock output
	MCOPRE CFGR = 0x07 << 28 //+ Microcontroller clock output prescaler
)

const (
	SWn     = 0
	SWSn    = 2
	HPREn   = 4
	PPRE1n  = 8
	PPRE2n  = 11
	MCOSELn = 24
	MCOPREn = 28
)

const (
	PLLSRC     PLLSYSCFGR = 0x03 << 0  //+ Main PLL, PLLSAI1 and PLLSAI2 entry clock source
	PLLSYSM    PLLSYSCFGR = 0x0F << 4  //+ Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
	PLLSYSN    PLLSYSCFGR = 0x7F << 8  //+ Main PLL multiplication factor for VCO
	PLLPEN     PLLSYSCFGR = 0x01 << 16 //+ Main PLL PLLSAI3CLK output enable
	PLLSYSP    PLLSYSCFGR = 0x01 << 17 //+ Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
	PLLSYSQEN  PLLSYSCFGR = 0x01 << 20 //+ Main PLL PLLUSB1CLK output enable
	PLLSYSQ    PLLSYSCFGR = 0x03 << 21 //+ Main PLL division factor for PLLUSB1CLK(48 MHz clock)
	PLLSYSREN  PLLSYSCFGR = 0x01 << 24 //+ Main PLL PLLCLK output enable
	PLLSYSR    PLLSYSCFGR = 0x03 << 25 //+ Main PLL division factor for PLLCLK (system clock)
	PLLSYSPDIV PLLSYSCFGR = 0x1F << 27 //+ Main PLL division factor for PLLSAI2CLK
)

const (
	PLLSRCn     = 0
	PLLSYSMn    = 4
	PLLSYSNn    = 8
	PLLPENn     = 16
	PLLSYSPn    = 17
	PLLSYSQENn  = 20
	PLLSYSQn    = 21
	PLLSYSRENn  = 24
	PLLSYSRn    = 25
	PLLSYSPDIVn = 27
)

const (
	LSIRDYIE    CIER = 0x01 << 0  //+ LSI ready interrupt enable
	LSERDYIE    CIER = 0x01 << 1  //+ LSE ready interrupt enable
	HSIRDYIE    CIER = 0x01 << 3  //+ HSI ready interrupt enable
	HSERDYIE    CIER = 0x01 << 4  //+ HSE ready interrupt enable
	PLLSYSRDYIE CIER = 0x01 << 5  //+ PLL ready interrupt enable
	LSECSSIE    CIER = 0x01 << 9  //+ LSE clock security system interrupt enable
	RC48RDYIE   CIER = 0x01 << 10 //+ HSI48 ready interrupt enable
)

const (
	LSIRDYIEn    = 0
	LSERDYIEn    = 1
	HSIRDYIEn    = 3
	HSERDYIEn    = 4
	PLLSYSRDYIEn = 5
	LSECSSIEn    = 9
	RC48RDYIEn   = 10
)

const (
	LSIRDYF    CIFR = 0x01 << 0  //+ LSI ready interrupt flag
	LSERDYF    CIFR = 0x01 << 1  //+ LSE ready interrupt flag
	HSIRDYF    CIFR = 0x01 << 3  //+ HSI ready interrupt flag
	HSERDYF    CIFR = 0x01 << 4  //+ HSE ready interrupt flag
	PLLSYSRDYF CIFR = 0x01 << 5  //+ PLL ready interrupt flag
	HSECSSF    CIFR = 0x01 << 8  //+ Clock security system interrupt flag
	LSECSSF    CIFR = 0x01 << 9  //+ LSE Clock security system interrupt flag
	RC48RDYF   CIFR = 0x01 << 10 //+ HSI48 ready interrupt flag
)

const (
	LSIRDYFn    = 0
	LSERDYFn    = 1
	HSIRDYFn    = 3
	HSERDYFn    = 4
	PLLSYSRDYFn = 5
	HSECSSFn    = 8
	LSECSSFn    = 9
	RC48RDYFn   = 10
)

const (
	LSIRDYC    CICR = 0x01 << 0  //+ LSI ready interrupt clear
	LSERDYC    CICR = 0x01 << 1  //+ LSE ready interrupt clear
	HSIRDYC    CICR = 0x01 << 3  //+ HSI ready interrupt clear
	HSERDYC    CICR = 0x01 << 4  //+ HSE ready interrupt clear
	PLLSYSRDYC CICR = 0x01 << 5  //+ PLL ready interrupt clear
	HSECSSC    CICR = 0x01 << 8  //+ Clock security system interrupt clear
	LSECSSC    CICR = 0x01 << 9  //+ LSE Clock security system interrupt clear
	RC48RDYC   CICR = 0x01 << 10 //+ HSI48 oscillator ready interrupt clear
)

const (
	LSIRDYCn    = 0
	LSERDYCn    = 1
	HSIRDYCn    = 3
	HSERDYCn    = 4
	PLLSYSRDYCn = 5
	HSECSSCn    = 8
	LSECSSCn    = 9
	RC48RDYCn   = 10
)

const (
	DMA1RST    AHB1RSTR = 0x01 << 0  //+ DMA1 reset
	DMA2RST    AHB1RSTR = 0x01 << 1  //+ DMA2 reset
	DMAMUX1RST AHB1RSTR = 0x01 << 2  //+ DMAMUXRST
	CORDICRST  AHB1RSTR = 0x01 << 3  //+ CORDIC reset
	MATRIXRST  AHB1RSTR = 0x01 << 4  //+ MATRIX reset
	FLITFRST_  AHB1RSTR = 0x01 << 8  //+ FLITF reset
	CRCRST     AHB1RSTR = 0x01 << 12 //+ CRC reset
)

const (
	DMA1RSTn    = 0
	DMA2RSTn    = 1
	DMAMUX1RSTn = 2
	CORDICRSTn  = 3
	MATRIXRSTn  = 4
	FLITFRST_n  = 8
	CRCRSTn     = 12
)

const (
	GPIOARST   AHB2RSTR = 0x01 << 0  //+ IO port A reset
	GPIOBRST   AHB2RSTR = 0x01 << 1  //+ IO port B reset
	GPIOCRST   AHB2RSTR = 0x01 << 2  //+ IO port C reset
	GPIODRST   AHB2RSTR = 0x01 << 3  //+ IO port D reset
	GPIOERST   AHB2RSTR = 0x01 << 4  //+ IO port E reset
	GPIOFRST   AHB2RSTR = 0x01 << 5  //+ IO port F reset
	GPIOGRST   AHB2RSTR = 0x01 << 6  //+ IO port G reset
	ADC12RST   AHB2RSTR = 0x01 << 13 //+ ADC reset
	ADC345RST_ AHB2RSTR = 0x01 << 14 //+ SAR ADC345 interface reset
	DAC1RST_   AHB2RSTR = 0x01 << 16 //+ DAC1 interface reset
	DAC2RST    AHB2RSTR = 0x01 << 17 //+ DAC2 interface reset
	DAC3RST    AHB2RSTR = 0x01 << 18 //+ DAC3 interface reset
	DAC4RST    AHB2RSTR = 0x01 << 19 //+ DAC4 interface reset
	CRYPTRST   AHB2RSTR = 0x01 << 24 //+ Cryptography module reset
	RNGRST     AHB2RSTR = 0x01 << 26 //+ Random Number Generator module reset
)

const (
	GPIOARSTn   = 0
	GPIOBRSTn   = 1
	GPIOCRSTn   = 2
	GPIODRSTn   = 3
	GPIOERSTn   = 4
	GPIOFRSTn   = 5
	GPIOGRSTn   = 6
	ADC12RSTn   = 13
	ADC345RST_n = 14
	DAC1RST_n   = 16
	DAC2RSTn    = 17
	DAC3RSTn    = 18
	DAC4RSTn    = 19
	CRYPTRSTn   = 24
	RNGRSTn     = 26
)

const (
	FMCRST      AHB3RSTR = 0x01 << 0 //+ Flexible memory controller reset
	QUADSPI1RST AHB3RSTR = 0x01 << 8 //+ Quad SPI 1 module reset
)

const (
	FMCRSTn      = 0
	QUADSPI1RSTn = 8
)

const (
	TIM2RST   APB1RSTR1 = 0x01 << 0  //+ TIM2 timer reset
	TIM3RST   APB1RSTR1 = 0x01 << 1  //+ TIM3 timer reset
	TIM4RST   APB1RSTR1 = 0x01 << 2  //+ TIM3 timer reset
	TIM5RST   APB1RSTR1 = 0x01 << 3  //+ TIM5 timer reset
	TIM6RST   APB1RSTR1 = 0x01 << 4  //+ TIM6 timer reset
	TIM7RST   APB1RSTR1 = 0x01 << 5  //+ TIM7 timer reset
	CRSRST    APB1RSTR1 = 0x01 << 8  //+ Clock recovery system reset
	SPI2RST   APB1RSTR1 = 0x01 << 14 //+ SPI2 reset
	SPI3RST   APB1RSTR1 = 0x01 << 15 //+ SPI3 reset
	USART2RST APB1RSTR1 = 0x01 << 17 //+ USART2 reset
	USART3RST APB1RSTR1 = 0x01 << 18 //+ USART3 reset
	UART4RST  APB1RSTR1 = 0x01 << 19 //+ UART4 reset
	UART5RST  APB1RSTR1 = 0x01 << 20 //+ UART5 reset
	I2C1RST   APB1RSTR1 = 0x01 << 21 //+ I2C1 reset
	I2C2RST   APB1RSTR1 = 0x01 << 22 //+ I2C2 reset
	USBDRST   APB1RSTR1 = 0x01 << 23 //+ USBD reset
	FDCANRST  APB1RSTR1 = 0x01 << 25 //+ FDCAN reset
	PWRRST    APB1RSTR1 = 0x01 << 28 //+ Power interface reset
	I2C3      APB1RSTR1 = 0x01 << 30 //+ I2C3 interface reset
	LPTIM1RST APB1RSTR1 = 0x01 << 31 //+ Low Power Timer 1 reset
)

const (
	TIM2RSTn   = 0
	TIM3RSTn   = 1
	TIM4RSTn   = 2
	TIM5RSTn   = 3
	TIM6RSTn   = 4
	TIM7RSTn   = 5
	CRSRSTn    = 8
	SPI2RSTn   = 14
	SPI3RSTn   = 15
	USART2RSTn = 17
	USART3RSTn = 18
	UART4RSTn  = 19
	UART5RSTn  = 20
	I2C1RSTn   = 21
	I2C2RSTn   = 22
	USBDRSTn   = 23
	FDCANRSTn  = 25
	PWRRSTn    = 28
	I2C3n      = 30
	LPTIM1RSTn = 31
)

const (
	LPUART1RST APB1RSTR2 = 0x01 << 0 //+ Low-power UART 1 reset
	I2C4RST    APB1RSTR2 = 0x01 << 1 //+ I2C4 reset
	USBPDRST   APB1RSTR2 = 0x01 << 8 //+ USBPD reset
)

const (
	LPUART1RSTn = 0
	I2C4RSTn    = 1
	USBPDRSTn   = 8
)

const (
	SYSCFGRST APB2RSTR = 0x01 << 0  //+ System configuration (SYSCFG) reset
	TIM1RST   APB2RSTR = 0x01 << 11 //+ TIM1 timer reset
	SPI1RST   APB2RSTR = 0x01 << 12 //+ SPI1 reset
	TIM8RST   APB2RSTR = 0x01 << 13 //+ TIM8 timer reset
	USART1RST APB2RSTR = 0x01 << 14 //+ USART1 reset
	SPI4RST   APB2RSTR = 0x01 << 15 //+ SPI 4 reset
	TIM15RST  APB2RSTR = 0x01 << 16 //+ TIM15 timer reset
	TIM16RST  APB2RSTR = 0x01 << 17 //+ TIM16 timer reset
	TIM17RST  APB2RSTR = 0x01 << 18 //+ TIM17 timer reset
	TIM20RST  APB2RSTR = 0x01 << 20 //+ Timer 20 reset
	SAI1RST   APB2RSTR = 0x01 << 21 //+ Serial audio interface 1 (SAI1) reset
	HRTIM1RST APB2RSTR = 0x01 << 26 //+ HRTIMER reset
)

const (
	SYSCFGRSTn = 0
	TIM1RSTn   = 11
	SPI1RSTn   = 12
	TIM8RSTn   = 13
	USART1RSTn = 14
	SPI4RSTn   = 15
	TIM15RSTn  = 16
	TIM16RSTn  = 17
	TIM17RSTn  = 18
	TIM20RSTn  = 20
	SAI1RSTn   = 21
	HRTIM1RSTn = 26
)

const (
	DMA1EN   AHB1ENR = 0x01 << 0  //+ DMA1 clock enable
	DMA2EN   AHB1ENR = 0x01 << 1  //+ DMA2 clock enable
	DMAMUXEN AHB1ENR = 0x01 << 2  //+ DMAMUX clock enable
	CORDICEN AHB1ENR = 0x01 << 3  //+ CORDIC clock enable
	FMACEN   AHB1ENR = 0x01 << 4  //+ FMAC clock enable
	FLITFEN  AHB1ENR = 0x01 << 8  //+ FLITF clock enable
	CRCEN    AHB1ENR = 0x01 << 12 //+ CRC clock enable
)

const (
	DMA1ENn   = 0
	DMA2ENn   = 1
	DMAMUXENn = 2
	CORDICENn = 3
	FMACENn   = 4
	FLITFENn  = 8
	CRCENn    = 12
)

const (
	GPIOAEN  AHB2ENR = 0x01 << 0  //+ IO port A clock enable
	GPIOBEN  AHB2ENR = 0x01 << 1  //+ IO port B clock enable
	GPIOCEN  AHB2ENR = 0x01 << 2  //+ IO port C clock enable
	GPIODEN  AHB2ENR = 0x01 << 3  //+ IO port D clock enable
	GPIOEEN  AHB2ENR = 0x01 << 4  //+ IO port E clock enable
	GPIOFEN  AHB2ENR = 0x01 << 5  //+ IO port F clock enable
	GPIOGEN  AHB2ENR = 0x01 << 6  //+ IO port G clock enable
	ADC12EN  AHB2ENR = 0x01 << 13 //+ ADC clock enable
	ADC345EN AHB2ENR = 0x01 << 14 //+ DCMI clock enable
	DAC1     AHB2ENR = 0x01 << 16 //+ DAC1 clock enable
	DAC2     AHB2ENR = 0x01 << 17 //+ DAC2 clock enable
	DAC3     AHB2ENR = 0x01 << 18 //+ DAC3 clock enable
	DAC4     AHB2ENR = 0x01 << 19 //+ DAC4 clock enable
	AESEN    AHB2ENR = 0x01 << 24 //+ AES clock enable
	RNGEN    AHB2ENR = 0x01 << 26 //+ Random Number Generator clock enable
)

const (
	GPIOAENn  = 0
	GPIOBENn  = 1
	GPIOCENn  = 2
	GPIODENn  = 3
	GPIOEENn  = 4
	GPIOFENn  = 5
	GPIOGENn  = 6
	ADC12ENn  = 13
	ADC345ENn = 14
	DAC1n     = 16
	DAC2n     = 17
	DAC3n     = 18
	DAC4n     = 19
	AESENn    = 24
	RNGENn    = 26
)

const (
	FMCEN      AHB3ENR = 0x01 << 0 //+ Flexible memory controller clock enable
	QUADSPI1EN AHB3ENR = 0x01 << 8 //+ Quad SPI 1 module clock enable
)

const (
	FMCENn      = 0
	QUADSPI1ENn = 8
)

const (
	TIM2EN   APB1ENR1 = 0x01 << 0  //+ TIM2 timer clock enable
	TIM3EN   APB1ENR1 = 0x01 << 1  //+ TIM3 timer clock enable
	TIM4EN   APB1ENR1 = 0x01 << 2  //+ TIM4 timer clock enable
	TIM5EN   APB1ENR1 = 0x01 << 3  //+ TIM5 timer clock enable
	TIM6EN   APB1ENR1 = 0x01 << 4  //+ TIM6 timer clock enable
	TIM7EN   APB1ENR1 = 0x01 << 5  //+ TIM7 timer clock enable
	CRSEN    APB1ENR1 = 0x01 << 8  //+ CRSclock enable
	RTCAPBEN APB1ENR1 = 0x01 << 10 //+ RTC APB clock enable
	WWDGEN   APB1ENR1 = 0x01 << 11 //+ Window watchdog clock enable
	SPI2EN   APB1ENR1 = 0x01 << 14 //+ SPI2 clock enable
	SPI3EN   APB1ENR1 = 0x01 << 15 //+ SPI3 clock enable
	USART2EN APB1ENR1 = 0x01 << 17 //+ USART2 clock enable
	USART3EN APB1ENR1 = 0x01 << 18 //+ USART3 clock enable
	UART4EN  APB1ENR1 = 0x01 << 19 //+ UART4 clock enable
	UART5EN  APB1ENR1 = 0x01 << 20 //+ UART5 clock enable
	I2C1EN   APB1ENR1 = 0x01 << 21 //+ I2C1 clock enable
	I2C2EN   APB1ENR1 = 0x01 << 22 //+ I2C2 clock enable
	USBDEN   APB1ENR1 = 0x01 << 23 //+ USBDclock enable
	FDCANEN  APB1ENR1 = 0x01 << 25 //+ FDCAN clock enable
	PWREN    APB1ENR1 = 0x01 << 28 //+ Power interface clock enable
	I2C3     APB1ENR1 = 0x01 << 30 //+ OPAMP interface clock enable
	LPTIM1EN APB1ENR1 = 0x01 << 31 //+ Low power timer 1 clock enable
)

const (
	TIM2ENn   = 0
	TIM3ENn   = 1
	TIM4ENn   = 2
	TIM5ENn   = 3
	TIM6ENn   = 4
	TIM7ENn   = 5
	CRSENn    = 8
	RTCAPBENn = 10
	WWDGENn   = 11
	SPI2ENn   = 14
	SPI3ENn   = 15
	USART2ENn = 17
	USART3ENn = 18
	UART4ENn  = 19
	UART5ENn  = 20
	I2C1ENn   = 21
	I2C2ENn   = 22
	USBDENn   = 23
	FDCANENn  = 25
	PWRENn    = 28
	I2C3n     = 30
	LPTIM1ENn = 31
)

const (
	LPUART1EN APB1ENR2 = 0x01 << 0 //+ Low power UART 1 clock enable
	I2C4EN    APB1ENR2 = 0x01 << 1 //+ I2C4 clock enable
	USBPDEN   APB1ENR2 = 0x01 << 8 //+ USBPD clock enable
)

const (
	LPUART1ENn = 0
	I2C4ENn    = 1
	USBPDENn   = 8
)

const (
	SYSCFGEN  APB2ENR = 0x01 << 0  //+ SYSCFG clock enable
	TIM1EN    APB2ENR = 0x01 << 11 //+ TIM1 timer clock enable
	SPI1EN    APB2ENR = 0x01 << 12 //+ SPI1 clock enable
	TIM8EN    APB2ENR = 0x01 << 13 //+ TIM8 timer clock enable
	USART1EN  APB2ENR = 0x01 << 14 //+ USART1clock enable
	SPI4EN    APB2ENR = 0x01 << 15 //+ SPI 4 clock enable
	TIM15EN   APB2ENR = 0x01 << 16 //+ TIM15 timer clock enable
	TIM16EN   APB2ENR = 0x01 << 17 //+ TIM16 timer clock enable
	TIM17EN   APB2ENR = 0x01 << 18 //+ TIM17 timer clock enable
	TIM20EN   APB2ENR = 0x01 << 20 //+ Timer 20 clock enable
	SAI1EN    APB2ENR = 0x01 << 21 //+ SAI1 clock enable
	HRTIMEREN APB2ENR = 0x01 << 26 //+ HRTIMER clock enable
)

const (
	SYSCFGENn  = 0
	TIM1ENn    = 11
	SPI1ENn    = 12
	TIM8ENn    = 13
	USART1ENn  = 14
	SPI4ENn    = 15
	TIM15ENn   = 16
	TIM16ENn   = 17
	TIM17ENn   = 18
	TIM20ENn   = 20
	SAI1ENn    = 21
	HRTIMERENn = 26
)

const (
	DMA1SMEN    AHB1SMENR = 0x01 << 0  //+ DMA1 clocks enable during Sleep and Stop modes
	DMA2SMEN    AHB1SMENR = 0x01 << 1  //+ DMA2 clocks enable during Sleep and Stop modes
	DMAMUX1SMEN AHB1SMENR = 0x01 << 2  //+ DMAMUX clock enable during Sleep and Stop modes
	CORDICSMEN  AHB1SMENR = 0x01 << 3  //+ CORDIC clock enable during sleep mode
	FMACSMEN    AHB1SMENR = 0x01 << 4  //+ FMACSM clock enable
	FLASHSMEN   AHB1SMENR = 0x01 << 8  //+ Flash memory interface clocks enable during Sleep and Stop modes
	SRAM1SMEN   AHB1SMENR = 0x01 << 9  //+ SRAM1 interface clocks enable during Sleep and Stop modes
	CRCSMEN     AHB1SMENR = 0x01 << 12 //+ CRCSMEN
)

const (
	DMA1SMENn    = 0
	DMA2SMENn    = 1
	DMAMUX1SMENn = 2
	CORDICSMENn  = 3
	FMACSMENn    = 4
	FLASHSMENn   = 8
	SRAM1SMENn   = 9
	CRCSMENn     = 12
)

const (
	GPIOASMEN  AHB2SMENR = 0x01 << 0  //+ IO port A clocks enable during Sleep and Stop modes
	GPIOBSMEN  AHB2SMENR = 0x01 << 1  //+ IO port B clocks enable during Sleep and Stop modes
	GPIOCSMEN  AHB2SMENR = 0x01 << 2  //+ IO port C clocks enable during Sleep and Stop modes
	GPIODSMEN  AHB2SMENR = 0x01 << 3  //+ IO port D clocks enable during Sleep and Stop modes
	GPIOESMEN  AHB2SMENR = 0x01 << 4  //+ IO port E clocks enable during Sleep and Stop modes
	GPIOFSMEN  AHB2SMENR = 0x01 << 5  //+ IO port F clocks enable during Sleep and Stop modes
	GPIOGSMEN  AHB2SMENR = 0x01 << 6  //+ IO port G clocks enable during Sleep and Stop modes
	SRAM2SMEN  AHB2SMENR = 0x01 << 9  //+ SRAM2 interface clocks enable during Sleep and Stop modes
	SRAM3SMEN  AHB2SMENR = 0x01 << 10 //+ SRAM2 interface clocks enable during Sleep and Stop modes
	AD12CSMEN  AHB2SMENR = 0x01 << 13 //+ ADC clocks enable during Sleep and Stop modes
	ADC345SMEN AHB2SMENR = 0x01 << 14 //+ DCMI clock enable during Sleep and Stop modes
	DAC1SMEN   AHB2SMENR = 0x01 << 16 //+ AES accelerator clocks enable during Sleep and Stop modes
	DAC2SMEN   AHB2SMENR = 0x01 << 17 //+ HASH clock enable during Sleep and Stop modes
	DAC3SMEN   AHB2SMENR = 0x01 << 18 //+ DAC3 clock enable during sleep mode
	DAC4SMEN   AHB2SMENR = 0x01 << 19 //+ DAC4 clock enable during sleep mode
	CRYPTSMEN  AHB2SMENR = 0x01 << 24 //+ Cryptography clock enable during sleep mode
	RNGSMEN    AHB2SMENR = 0x01 << 26 //+ Random Number Generator clock enable during sleep mode
)

const (
	GPIOASMENn  = 0
	GPIOBSMENn  = 1
	GPIOCSMENn  = 2
	GPIODSMENn  = 3
	GPIOESMENn  = 4
	GPIOFSMENn  = 5
	GPIOGSMENn  = 6
	SRAM2SMENn  = 9
	SRAM3SMENn  = 10
	AD12CSMENn  = 13
	ADC345SMENn = 14
	DAC1SMENn   = 16
	DAC2SMENn   = 17
	DAC3SMENn   = 18
	DAC4SMENn   = 19
	CRYPTSMENn  = 24
	RNGSMENn    = 26
)

const (
	FMCSMEN      AHB3SMENR = 0x01 << 0 //+ Flexible memory controller clocks enable during Sleep and Stop modes
	QUADSPI1SMEN AHB3SMENR = 0x01 << 8 //+ QUAD SPI 1 module clock enable during sleep mode
)

const (
	FMCSMENn      = 0
	QUADSPI1SMENn = 8
)

const (
	TIM2SMEN   APB1SMENR1 = 0x01 << 0  //+ TIM2 timer clocks enable during Sleep and Stop modes
	TIM3SMEN   APB1SMENR1 = 0x01 << 1  //+ TIM3 timer clocks enable during Sleep and Stop modes
	TIM4SMEN   APB1SMENR1 = 0x01 << 2  //+ TIM4 timer clocks enable during Sleep and Stop modes
	TIM5SMEN   APB1SMENR1 = 0x01 << 3  //+ TIM5 timer clocks enable during Sleep and Stop modes
	TIM6SMEN   APB1SMENR1 = 0x01 << 4  //+ TIM6 timer clocks enable during Sleep and Stop modes
	TIM7SMEN   APB1SMENR1 = 0x01 << 5  //+ TIM7 timer clocks enable during Sleep and Stop modes
	CRSSMEN    APB1SMENR1 = 0x01 << 8  //+ CRS clock enable during sleep mode
	RTCAPBSMEN APB1SMENR1 = 0x01 << 10 //+ RTC APB clock enable during Sleep and Stop modes
	WWDGSMEN   APB1SMENR1 = 0x01 << 11 //+ Window watchdog clocks enable during Sleep and Stop modes
	SPI2SMEN   APB1SMENR1 = 0x01 << 14 //+ SPI2 clocks enable during Sleep and Stop modes
	SP3SMEN    APB1SMENR1 = 0x01 << 15 //+ SPI3 clocks enable during Sleep and Stop modes
	USART2SMEN APB1SMENR1 = 0x01 << 17 //+ USART2 clocks enable during Sleep and Stop modes
	USART3SMEN APB1SMENR1 = 0x01 << 18 //+ USART3 clocks enable during Sleep and Stop modes
	UART4SMEN  APB1SMENR1 = 0x01 << 19 //+ UART4 clocks enable during Sleep and Stop modes
	UART5SMEN  APB1SMENR1 = 0x01 << 20 //+ UART5 clocks enable during Sleep and Stop modes
	I2C1SMEN   APB1SMENR1 = 0x01 << 21 //+ I2C1 clocks enable during Sleep and Stop modes
	I2C2SMEN   APB1SMENR1 = 0x01 << 22 //+ I2C2 clocks enable during Sleep and Stop modes
	I2C3SMEN   APB1SMENR1 = 0x01 << 23 //+ I2C3 clocks enable during Sleep and Stop modes
	FDCANSMEN  APB1SMENR1 = 0x01 << 25 //+ FDCAN clock enable during sleep mode
	PWRSMEN    APB1SMENR1 = 0x01 << 28 //+ Power interface clocks enable during Sleep and Stop modes
	I2C3SMEN_3 APB1SMENR1 = 0x01 << 30 //+ I2C 3 interface clock enable during sleep mode
	LPTIM1SMEN APB1SMENR1 = 0x01 << 31 //+ Low Power Timer1 clock enable during sleep mode
)

const (
	TIM2SMENn   = 0
	TIM3SMENn   = 1
	TIM4SMENn   = 2
	TIM5SMENn   = 3
	TIM6SMENn   = 4
	TIM7SMENn   = 5
	CRSSMENn    = 8
	RTCAPBSMENn = 10
	WWDGSMENn   = 11
	SPI2SMENn   = 14
	SP3SMENn    = 15
	USART2SMENn = 17
	USART3SMENn = 18
	UART4SMENn  = 19
	UART5SMENn  = 20
	I2C1SMENn   = 21
	I2C2SMENn   = 22
	I2C3SMENn   = 23
	FDCANSMENn  = 25
	PWRSMENn    = 28
	I2C3SMEN_3n = 30
	LPTIM1SMENn = 31
)

const (
	LPUART1SMEN APB1SMENR2 = 0x01 << 0 //+ Low power UART 1 clocks enable during Sleep and Stop modes
	I2C4SMEN    APB1SMENR2 = 0x01 << 1 //+ I2C4 clocks enable during Sleep and Stop modes
	USBPDSMEN   APB1SMENR2 = 0x01 << 8 //+ USB PD clock enable during sleep mode
)

const (
	LPUART1SMENn = 0
	I2C4SMENn    = 1
	USBPDSMENn   = 8
)

const (
	SYSCFGSMEN  APB2SMENR = 0x01 << 0  //+ SYSCFG clocks enable during Sleep and Stop modes
	TIM1SMEN    APB2SMENR = 0x01 << 11 //+ TIM1 timer clocks enable during Sleep and Stop modes
	SPI1SMEN    APB2SMENR = 0x01 << 12 //+ SPI1 clocks enable during Sleep and Stop modes
	TIM8SMEN    APB2SMENR = 0x01 << 13 //+ TIM8 timer clocks enable during Sleep and Stop modes
	USART1SMEN  APB2SMENR = 0x01 << 14 //+ USART1clocks enable during Sleep and Stop modes
	SPI4SMEN    APB2SMENR = 0x01 << 15 //+ SPI4 timer clocks enable during Sleep and Stop modes
	TIM15SMEN   APB2SMENR = 0x01 << 16 //+ TIM15 timer clocks enable during Sleep and Stop modes
	TIM16SMEN   APB2SMENR = 0x01 << 17 //+ TIM16 timer clocks enable during Sleep and Stop modes
	TIM17SMEN   APB2SMENR = 0x01 << 18 //+ TIM17 timer clocks enable during Sleep and Stop modes
	TIM20SMEN   APB2SMENR = 0x01 << 20 //+ Timer 20clock enable during sleep mode
	SAI1SMEN    APB2SMENR = 0x01 << 21 //+ SAI1 clock enable during sleep mode
	HRTIMERSMEN APB2SMENR = 0x01 << 26 //+ HRTIMER clock enable during sleep mode
)

const (
	SYSCFGSMENn  = 0
	TIM1SMENn    = 11
	SPI1SMENn    = 12
	TIM8SMENn    = 13
	USART1SMENn  = 14
	SPI4SMENn    = 15
	TIM15SMENn   = 16
	TIM16SMENn   = 17
	TIM17SMENn   = 18
	TIM20SMENn   = 20
	SAI1SMENn    = 21
	HRTIMERSMENn = 26
)

const (
	USART1SEL  CCIPR1 = 0x03 << 0  //+ USART1 clock source selection
	USART2SEL  CCIPR1 = 0x03 << 2  //+ USART2 clock source selection
	USART3SEL  CCIPR1 = 0x03 << 4  //+ USART3 clock source selection
	UART4SEL   CCIPR1 = 0x03 << 6  //+ UART4 clock source selection
	UART5SEL   CCIPR1 = 0x03 << 8  //+ UART5 clock source selection
	LPUART1SEL CCIPR1 = 0x03 << 10 //+ LPUART1 clock source selection
	I2C1SEL    CCIPR1 = 0x03 << 12 //+ I2C1 clock source selection
	I2C2SEL    CCIPR1 = 0x03 << 14 //+ I2C2 clock source selection
	I2C3SEL    CCIPR1 = 0x03 << 16 //+ I2C3 clock source selection
	LPTIM1SEL  CCIPR1 = 0x03 << 18 //+ Low power timer 1 clock source selection
	SAISEL     CCIPR1 = 0x03 << 20 //+ Low power timer 2 clock source selection
	SPISEL_    CCIPR1 = 0x03 << 22 //+ SAI1 clock source selection
	FDCANSEL   CCIPR1 = 0x03 << 24 //+ SAI2 clock source selection
	CLK48SEL   CCIPR1 = 0x03 << 26 //+ 48 MHz clock source selection
	ADCSEL     CCIPR1 = 0x03 << 28 //+ ADCs clock source selection
	ADC345SEL  CCIPR1 = 0x03 << 30 //+ ADC3/4/5 clock source selection
)

const (
	USART1SELn  = 0
	USART2SELn  = 2
	USART3SELn  = 4
	UART4SELn   = 6
	UART5SELn   = 8
	LPUART1SELn = 10
	I2C1SELn    = 12
	I2C2SELn    = 14
	I2C3SELn    = 16
	LPTIM1SELn  = 18
	SAISELn     = 20
	SPISEL_n    = 22
	FDCANSELn   = 24
	CLK48SELn   = 26
	ADCSELn     = 28
	ADC345SELn  = 30
)

const (
	LSEON    BDCR = 0x01 << 0  //+ LSE oscillator enable
	LSERDY   BDCR = 0x01 << 1  //+ LSE oscillator ready
	LSEBYP   BDCR = 0x01 << 2  //+ LSE oscillator bypass
	LSEDRV   BDCR = 0x03 << 3  //+ SE oscillator drive capability
	LSECSSON BDCR = 0x01 << 5  //+ LSECSSON
	LSECSSD  BDCR = 0x01 << 6  //+ LSECSSD
	RTCSEL   BDCR = 0x03 << 8  //+ RTC clock source selection
	RTCEN    BDCR = 0x01 << 15 //+ RTC clock enable
	VSWRST   BDCR = 0x01 << 16 //+ Vswitch domain software reset
	LSCCOEN  BDCR = 0x01 << 24 //+ Low speed clock output enable
	LSCOSEL  BDCR = 0x01 << 25 //+ Low speed clock output selection
)

const (
	LSEONn    = 0
	LSERDYn   = 1
	LSEBYPn   = 2
	LSEDRVn   = 3
	LSECSSONn = 5
	LSECSSDn  = 6
	RTCSELn   = 8
	RTCENn    = 15
	VSWRSTn   = 16
	LSCCOENn  = 24
	LSCOSELn  = 25
)

const (
	LSION    CSR = 0x01 << 0  //+ LSI oscillator enable
	LSIRDY   CSR = 0x01 << 1  //+ LSI oscillator ready
	RMVF     CSR = 0x01 << 23 //+ Remove reset flag
	OBLRSTF  CSR = 0x01 << 25 //+ Option byte loader reset flag
	PADRSTF  CSR = 0x01 << 26 //+ Pad reset flag
	BORRSTF  CSR = 0x01 << 27 //+ BOR flag
	SFTRSTF  CSR = 0x01 << 28 //+ Software reset flag
	WDGRSTF  CSR = 0x01 << 29 //+ Independent window watchdog reset flag
	WWDGRSTF CSR = 0x01 << 30 //+ Window watchdog reset flag
	LPWRSTF  CSR = 0x01 << 31 //+ Low-power reset flag
)

const (
	LSIONn    = 0
	LSIRDYn   = 1
	RMVFn     = 23
	OBLRSTFn  = 25
	PADRSTFn  = 26
	BORRSTFn  = 27
	SFTRSTFn  = 28
	WDGRSTFn  = 29
	WWDGRSTFn = 30
	LPWRSTFn  = 31
)

const (
	RC48ON  CRRCR = 0x01 << 0  //+ HSI48 clock enable
	RC48RDY CRRCR = 0x01 << 1  //+ HSI48 clock ready flag
	RC48CAL CRRCR = 0x1FF << 7 //+ HSI48 clock calibration
)

const (
	RC48ONn  = 0
	RC48RDYn = 1
	RC48CALn = 7
)

const (
	I2C4SEL    CCIPR2 = 0x03 << 0  //+ I2C4 clock source selection
	QUADSPISEL CCIPR2 = 0x03 << 20 //+ Octospi clock source selection
)

const (
	I2C4SELn    = 0
	QUADSPISELn = 20
)
