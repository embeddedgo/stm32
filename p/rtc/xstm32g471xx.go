// DO NOT EDIT THIS FILE. GENERATED BY xgen.

//go:build stm32g471xx

package rtc

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	TR       mmio.R32[TR]
	DR       mmio.R32[DR]
	SSR      mmio.R32[SSR]
	ICSR     mmio.R32[ICSR]
	PRER     mmio.R32[PRER]
	WUTR     mmio.R32[WUTR]
	CR       mmio.R32[CR]
	_        [2]uint32
	WPR      mmio.R32[WPR]
	CALR     mmio.R32[CALR]
	SHIFTR   mmio.R32[SHIFTR]
	TSTR     mmio.R32[TR]
	TSDR     mmio.R32[DR]
	TSSSR    mmio.R32[SSR]
	_        uint32
	ALRMAR   mmio.R32[ALRMR]
	ALRMASSR mmio.R32[ALRMSSR]
	ALRMBR   mmio.R32[ALRMR]
	ALRMBSSR mmio.R32[ALRMSSR]
	SR       mmio.R32[SR]
	MISR     mmio.R32[MISR]
	_        uint32
	SCR      mmio.R32[SCR]
}

func RTC() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.RTC_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type TR uint32

func SU_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{&p.TR, SU} }
func ST_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{&p.TR, ST} }
func MNU_(p *Periph) mmio.RM32[TR] { return mmio.RM32[TR]{&p.TR, MNU} }
func MNT_(p *Periph) mmio.RM32[TR] { return mmio.RM32[TR]{&p.TR, MNT} }
func HU_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{&p.TR, HU} }
func HT_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{&p.TR, HT} }
func PM_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{&p.TR, PM} }

type DR uint32

func DU_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{&p.DR, DU} }
func DT_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{&p.DR, DT} }
func MU_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{&p.DR, MU} }
func MT_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{&p.DR, MT} }
func WDU_(p *Periph) mmio.RM32[DR] { return mmio.RM32[DR]{&p.DR, WDU} }
func YU_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{&p.DR, YU} }
func YT_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{&p.DR, YT} }

type SSR uint32

func SS_(p *Periph) mmio.RM32[SSR] { return mmio.RM32[SSR]{&p.SSR, SS} }

type ICSR uint32

func ALRAWF_(p *Periph) mmio.RM32[ICSR]  { return mmio.RM32[ICSR]{&p.ICSR, ALRAWF} }
func ALRBWF_(p *Periph) mmio.RM32[ICSR]  { return mmio.RM32[ICSR]{&p.ICSR, ALRBWF} }
func WUTWF_(p *Periph) mmio.RM32[ICSR]   { return mmio.RM32[ICSR]{&p.ICSR, WUTWF} }
func SHPF_(p *Periph) mmio.RM32[ICSR]    { return mmio.RM32[ICSR]{&p.ICSR, SHPF} }
func INITS_(p *Periph) mmio.RM32[ICSR]   { return mmio.RM32[ICSR]{&p.ICSR, INITS} }
func RSF_(p *Periph) mmio.RM32[ICSR]     { return mmio.RM32[ICSR]{&p.ICSR, RSF} }
func INITF_(p *Periph) mmio.RM32[ICSR]   { return mmio.RM32[ICSR]{&p.ICSR, INITF} }
func INIT_(p *Periph) mmio.RM32[ICSR]    { return mmio.RM32[ICSR]{&p.ICSR, INIT} }
func RECALPF_(p *Periph) mmio.RM32[ICSR] { return mmio.RM32[ICSR]{&p.ICSR, RECALPF} }

type PRER uint32

func PREDIV_S_(p *Periph) mmio.RM32[PRER] { return mmio.RM32[PRER]{&p.PRER, PREDIV_S} }
func PREDIV_A_(p *Periph) mmio.RM32[PRER] { return mmio.RM32[PRER]{&p.PRER, PREDIV_A} }

type WUTR uint32

func WUT_(p *Periph) mmio.RM32[WUTR] { return mmio.RM32[WUTR]{&p.WUTR, WUT} }

type CR uint32

func WCKSEL_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, WCKSEL} }
func TSEDGE_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, TSEDGE} }
func REFCKON_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{&p.CR, REFCKON} }
func BYPSHAD_(p *Periph) mmio.RM32[CR]       { return mmio.RM32[CR]{&p.CR, BYPSHAD} }
func FMT_(p *Periph) mmio.RM32[CR]           { return mmio.RM32[CR]{&p.CR, FMT} }
func ALRAE_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, ALRAE} }
func ALRBE_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, ALRBE} }
func WUTE_(p *Periph) mmio.RM32[CR]          { return mmio.RM32[CR]{&p.CR, WUTE} }
func TSE_(p *Periph) mmio.RM32[CR]           { return mmio.RM32[CR]{&p.CR, TSE} }
func ALRAIE_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, ALRAIE} }
func ALRBIE_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, ALRBIE} }
func WUTIE_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, WUTIE} }
func TSIE_(p *Periph) mmio.RM32[CR]          { return mmio.RM32[CR]{&p.CR, TSIE} }
func ADD1H_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, ADD1H} }
func SUB1H_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, SUB1H} }
func BKP_(p *Periph) mmio.RM32[CR]           { return mmio.RM32[CR]{&p.CR, BKP} }
func COSEL_(p *Periph) mmio.RM32[CR]         { return mmio.RM32[CR]{&p.CR, COSEL} }
func POL_(p *Periph) mmio.RM32[CR]           { return mmio.RM32[CR]{&p.CR, POL} }
func OSEL_(p *Periph) mmio.RM32[CR]          { return mmio.RM32[CR]{&p.CR, OSEL} }
func COE_(p *Periph) mmio.RM32[CR]           { return mmio.RM32[CR]{&p.CR, COE} }
func ITSE_(p *Periph) mmio.RM32[CR]          { return mmio.RM32[CR]{&p.CR, ITSE} }
func TAMPTS_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, TAMPTS} }
func TAMPOE_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, TAMPOE} }
func TAMPALRM_PU_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{&p.CR, TAMPALRM_PU} }
func TAMPALRM_TYPE_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{&p.CR, TAMPALRM_TYPE} }
func OUT2EN_(p *Periph) mmio.RM32[CR]        { return mmio.RM32[CR]{&p.CR, OUT2EN} }

type WPR uint32

func KEY_(p *Periph) mmio.RM32[WPR] { return mmio.RM32[WPR]{&p.WPR, KEY} }

type CALR uint32

func CALM_(p *Periph) mmio.RM32[CALR]   { return mmio.RM32[CALR]{&p.CALR, CALM} }
func CALW16_(p *Periph) mmio.RM32[CALR] { return mmio.RM32[CALR]{&p.CALR, CALW16} }
func CALW8_(p *Periph) mmio.RM32[CALR]  { return mmio.RM32[CALR]{&p.CALR, CALW8} }
func CALP_(p *Periph) mmio.RM32[CALR]   { return mmio.RM32[CALR]{&p.CALR, CALP} }

type SHIFTR uint32

func SUBFS_(p *Periph) mmio.RM32[SHIFTR] { return mmio.RM32[SHIFTR]{&p.SHIFTR, SUBFS} }
func ADD1S_(p *Periph) mmio.RM32[SHIFTR] { return mmio.RM32[SHIFTR]{&p.SHIFTR, ADD1S} }

type ALRMR uint32

type ALRMSSR uint32

type SR uint32

func ALRAF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{&p.SR, ALRAF} }
func ALRBF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{&p.SR, ALRBF} }
func WUTF_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, WUTF} }
func TSF_(p *Periph) mmio.RM32[SR]   { return mmio.RM32[SR]{&p.SR, TSF} }
func TSOVF_(p *Periph) mmio.RM32[SR] { return mmio.RM32[SR]{&p.SR, TSOVF} }
func ITSF_(p *Periph) mmio.RM32[SR]  { return mmio.RM32[SR]{&p.SR, ITSF} }

type MISR uint32

func ALRAMF_(p *Periph) mmio.RM32[MISR] { return mmio.RM32[MISR]{&p.MISR, ALRAMF} }
func ALRBMF_(p *Periph) mmio.RM32[MISR] { return mmio.RM32[MISR]{&p.MISR, ALRBMF} }
func WUTMF_(p *Periph) mmio.RM32[MISR]  { return mmio.RM32[MISR]{&p.MISR, WUTMF} }
func TSMF_(p *Periph) mmio.RM32[MISR]   { return mmio.RM32[MISR]{&p.MISR, TSMF} }
func TSOVMF_(p *Periph) mmio.RM32[MISR] { return mmio.RM32[MISR]{&p.MISR, TSOVMF} }
func ITSMF_(p *Periph) mmio.RM32[MISR]  { return mmio.RM32[MISR]{&p.MISR, ITSMF} }

type SCR uint32

func CALRAF_(p *Periph) mmio.RM32[SCR] { return mmio.RM32[SCR]{&p.SCR, CALRAF} }
func CALRBF_(p *Periph) mmio.RM32[SCR] { return mmio.RM32[SCR]{&p.SCR, CALRBF} }
func CWUTF_(p *Periph) mmio.RM32[SCR]  { return mmio.RM32[SCR]{&p.SCR, CWUTF} }
func CTSF_(p *Periph) mmio.RM32[SCR]   { return mmio.RM32[SCR]{&p.SCR, CTSF} }
func CTSOVF_(p *Periph) mmio.RM32[SCR] { return mmio.RM32[SCR]{&p.SCR, CTSOVF} }
func CITSF_(p *Periph) mmio.RM32[SCR]  { return mmio.RM32[SCR]{&p.SCR, CITSF} }
