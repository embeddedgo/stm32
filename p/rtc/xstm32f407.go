// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32f407

package rtc

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	TR       mmio.R32[TR]
	DR       mmio.R32[DR]
	CR       mmio.R32[CR]
	ISR      mmio.R32[ISR]
	PRER     mmio.R32[PRER]
	WUTR     mmio.R32[WUTR]
	CALIBR   mmio.R32[CALIBR]
	ALRMAR   mmio.R32[ALRMR]
	ALRMBR   mmio.R32[ALRMR]
	WPR      mmio.R32[WPR]
	SSR      mmio.R32[SSR]
	SHIFTR   mmio.R32[SHIFTR]
	TSTR     mmio.R32[TR]
	TSDR     mmio.R32[DR]
	TSSSR    mmio.R32[SSR]
	CALR     mmio.R32[CALR]
	TAFCR    mmio.R32[TAFCR]
	ALRMASSR mmio.R32[ALRMSSR]
	ALRMBSSR mmio.R32[ALRMSSR]
	_        uint32
	BKPR     [20]mmio.R32[uint32]
}

func RTC() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.RTC_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type TR uint32

func SU_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{R: &p.TR, Mask: SU} }
func ST_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{R: &p.TR, Mask: ST} }
func MNU_(p *Periph) mmio.RM32[TR] { return mmio.RM32[TR]{R: &p.TR, Mask: MNU} }
func MNT_(p *Periph) mmio.RM32[TR] { return mmio.RM32[TR]{R: &p.TR, Mask: MNT} }
func HU_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{R: &p.TR, Mask: HU} }
func HT_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{R: &p.TR, Mask: HT} }
func PM_(p *Periph) mmio.RM32[TR]  { return mmio.RM32[TR]{R: &p.TR, Mask: PM} }

type DR uint32

func DU_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{R: &p.DR, Mask: DU} }
func DT_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{R: &p.DR, Mask: DT} }
func MU_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{R: &p.DR, Mask: MU} }
func MT_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{R: &p.DR, Mask: MT} }
func WDU_(p *Periph) mmio.RM32[DR] { return mmio.RM32[DR]{R: &p.DR, Mask: WDU} }
func YU_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{R: &p.DR, Mask: YU} }
func YT_(p *Periph) mmio.RM32[DR]  { return mmio.RM32[DR]{R: &p.DR, Mask: YT} }

type CR uint32

func WCKSEL_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: WCKSEL} }
func TSEDGE_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: TSEDGE} }
func REFCKON_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: REFCKON} }
func BYPSHAD_(p *Periph) mmio.RM32[CR] { return mmio.RM32[CR]{R: &p.CR, Mask: BYPSHAD} }
func FMT_(p *Periph) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.CR, Mask: FMT} }
func DCE_(p *Periph) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.CR, Mask: DCE} }
func ALRAE_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: ALRAE} }
func ALRBE_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: ALRBE} }
func WUTE_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: WUTE} }
func TSE_(p *Periph) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.CR, Mask: TSE} }
func ALRAIE_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: ALRAIE} }
func ALRBIE_(p *Periph) mmio.RM32[CR]  { return mmio.RM32[CR]{R: &p.CR, Mask: ALRBIE} }
func WUTIE_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: WUTIE} }
func TSIE_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: TSIE} }
func ADD1H_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: ADD1H} }
func SUB1H_(p *Periph) mmio.RM32[CR]   { return mmio.RM32[CR]{R: &p.CR, Mask: SUB1H} }
func BKP_(p *Periph) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.CR, Mask: BKP} }
func POL_(p *Periph) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.CR, Mask: POL} }
func OSEL_(p *Periph) mmio.RM32[CR]    { return mmio.RM32[CR]{R: &p.CR, Mask: OSEL} }
func COE_(p *Periph) mmio.RM32[CR]     { return mmio.RM32[CR]{R: &p.CR, Mask: COE} }

type ISR uint32

func ALRAWF_(p *Periph) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR, Mask: ALRAWF} }
func ALRBWF_(p *Periph) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR, Mask: ALRBWF} }
func WUTWF_(p *Periph) mmio.RM32[ISR]   { return mmio.RM32[ISR]{R: &p.ISR, Mask: WUTWF} }
func SHPF_(p *Periph) mmio.RM32[ISR]    { return mmio.RM32[ISR]{R: &p.ISR, Mask: SHPF} }
func INITS_(p *Periph) mmio.RM32[ISR]   { return mmio.RM32[ISR]{R: &p.ISR, Mask: INITS} }
func RSF_(p *Periph) mmio.RM32[ISR]     { return mmio.RM32[ISR]{R: &p.ISR, Mask: RSF} }
func INITF_(p *Periph) mmio.RM32[ISR]   { return mmio.RM32[ISR]{R: &p.ISR, Mask: INITF} }
func INIT_(p *Periph) mmio.RM32[ISR]    { return mmio.RM32[ISR]{R: &p.ISR, Mask: INIT} }
func ALRAF_(p *Periph) mmio.RM32[ISR]   { return mmio.RM32[ISR]{R: &p.ISR, Mask: ALRAF} }
func ALRBF_(p *Periph) mmio.RM32[ISR]   { return mmio.RM32[ISR]{R: &p.ISR, Mask: ALRBF} }
func WUTF_(p *Periph) mmio.RM32[ISR]    { return mmio.RM32[ISR]{R: &p.ISR, Mask: WUTF} }
func TSF_(p *Periph) mmio.RM32[ISR]     { return mmio.RM32[ISR]{R: &p.ISR, Mask: TSF} }
func TSOVF_(p *Periph) mmio.RM32[ISR]   { return mmio.RM32[ISR]{R: &p.ISR, Mask: TSOVF} }
func TAMP1F_(p *Periph) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR, Mask: TAMP1F} }
func TAMP2F_(p *Periph) mmio.RM32[ISR]  { return mmio.RM32[ISR]{R: &p.ISR, Mask: TAMP2F} }
func RECALPF_(p *Periph) mmio.RM32[ISR] { return mmio.RM32[ISR]{R: &p.ISR, Mask: RECALPF} }

type PRER uint32

func PREDIV_S_(p *Periph) mmio.RM32[PRER] { return mmio.RM32[PRER]{R: &p.PRER, Mask: PREDIV_S} }
func PREDIV_A_(p *Periph) mmio.RM32[PRER] { return mmio.RM32[PRER]{R: &p.PRER, Mask: PREDIV_A} }

type WUTR uint32

func WUT_(p *Periph) mmio.RM32[WUTR] { return mmio.RM32[WUTR]{R: &p.WUTR, Mask: WUT} }

type CALIBR uint32

func DC_(p *Periph) mmio.RM32[CALIBR]  { return mmio.RM32[CALIBR]{R: &p.CALIBR, Mask: DC} }
func DCS_(p *Periph) mmio.RM32[CALIBR] { return mmio.RM32[CALIBR]{R: &p.CALIBR, Mask: DCS} }

type ALRMR uint32

type WPR uint32

func KEY_(p *Periph) mmio.RM32[WPR] { return mmio.RM32[WPR]{R: &p.WPR, Mask: KEY} }

type SSR uint32

func SS_(p *Periph) mmio.RM32[SSR] { return mmio.RM32[SSR]{R: &p.SSR, Mask: SS} }

type SHIFTR uint32

func SUBFS_(p *Periph) mmio.RM32[SHIFTR] { return mmio.RM32[SHIFTR]{R: &p.SHIFTR, Mask: SUBFS} }
func ADD1S_(p *Periph) mmio.RM32[SHIFTR] { return mmio.RM32[SHIFTR]{R: &p.SHIFTR, Mask: ADD1S} }

type CALR uint32

func CALM_(p *Periph) mmio.RM32[CALR]   { return mmio.RM32[CALR]{R: &p.CALR, Mask: CALM} }
func CALW16_(p *Periph) mmio.RM32[CALR] { return mmio.RM32[CALR]{R: &p.CALR, Mask: CALW16} }
func CALW8_(p *Periph) mmio.RM32[CALR]  { return mmio.RM32[CALR]{R: &p.CALR, Mask: CALW8} }
func CALP_(p *Periph) mmio.RM32[CALR]   { return mmio.RM32[CALR]{R: &p.CALR, Mask: CALP} }

type TAFCR uint32

func TAMP1E_(p *Periph) mmio.RM32[TAFCR]     { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMP1E} }
func TAMP1TRG_(p *Periph) mmio.RM32[TAFCR]   { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMP1TRG} }
func TAMPIE_(p *Periph) mmio.RM32[TAFCR]     { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMPIE} }
func TAMP2E_(p *Periph) mmio.RM32[TAFCR]     { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMP2E} }
func TAMP2TRG_(p *Periph) mmio.RM32[TAFCR]   { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMP2TRG} }
func TAMPTS_(p *Periph) mmio.RM32[TAFCR]     { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMPTS} }
func TAMPFREQ_(p *Periph) mmio.RM32[TAFCR]   { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMPFREQ} }
func TAMPFLT_(p *Periph) mmio.RM32[TAFCR]    { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMPFLT} }
func TAMPPRCH_(p *Periph) mmio.RM32[TAFCR]   { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMPPRCH} }
func TAMPPUDIS_(p *Periph) mmio.RM32[TAFCR]  { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMPPUDIS} }
func TAMP1INSEL_(p *Periph) mmio.RM32[TAFCR] { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TAMP1INSEL} }
func TSINSEL_(p *Periph) mmio.RM32[TAFCR]    { return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: TSINSEL} }
func ALARMOUTTYPE_(p *Periph) mmio.RM32[TAFCR] {
	return mmio.RM32[TAFCR]{R: &p.TAFCR, Mask: ALARMOUTTYPE}
}

type ALRMSSR uint32
