// Code generated by xgen -g; DO NOT EDIT.

//go:build stm32h7x3

package syscfg

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/stm32/p/bus"
	"github.com/embeddedgo/stm32/p/mmap"
)

type Periph struct {
	_      uint32
	PMCR   mmio.R32[PMCR]
	EXTICR [4]mmio.R32[uint32]
	_      [2]uint32
	CCCSR  mmio.R32[CCCSR]
	CCVR   mmio.R32[CCVR]
	CCCR   mmio.R32[CCCR]
	PWRCR  mmio.R32[PWRCR]
	_      [61]uint32
	PKGR   mmio.R32[PKGR]
	_      [118]uint32
	UR0    mmio.R32[UR0]
	_      uint32
	UR2    mmio.R32[UR2]
	UR3    mmio.R32[UR3]
	UR4    mmio.R32[UR4]
	UR5    mmio.R32[UR5]
	UR6    mmio.R32[UR6]
	UR7    mmio.R32[UR7]
	UR8    mmio.R32[UR8]
	UR9    mmio.R32[UR9]
	UR10   mmio.R32[UR10]
	UR11   mmio.R32[UR11]
	UR12   mmio.R32[UR12]
	UR13   mmio.R32[UR13]
	UR14   mmio.R32[UR14]
	UR15   mmio.R32[UR15]
	UR16   mmio.R32[UR16]
	UR17   mmio.R32[UR17]
}

func SYSCFG() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.SYSCFG_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

func (p *Periph) Bus() bus.Bus {
	return bus.APB4
}

type PMCR uint32

func I2C1FMP_(p *Periph) mmio.RM32[PMCR]     { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: I2C1FMP} }
func I2C2FMP_(p *Periph) mmio.RM32[PMCR]     { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: I2C2FMP} }
func I2C3FMP_(p *Periph) mmio.RM32[PMCR]     { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: I2C3FMP} }
func I2C4FMP_(p *Periph) mmio.RM32[PMCR]     { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: I2C4FMP} }
func PB6FMP_(p *Periph) mmio.RM32[PMCR]      { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PB6FMP} }
func PB7FMP_(p *Periph) mmio.RM32[PMCR]      { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PB7FMP} }
func PB8FMP_(p *Periph) mmio.RM32[PMCR]      { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PB8FMP} }
func PB9FMP_(p *Periph) mmio.RM32[PMCR]      { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PB9FMP} }
func BOOSTE_(p *Periph) mmio.RM32[PMCR]      { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: BOOSTE} }
func BOOSTVDDSEL_(p *Periph) mmio.RM32[PMCR] { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: BOOSTVDDSEL} }
func EPIS_(p *Periph) mmio.RM32[PMCR]        { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: EPIS} }
func PA0SO_(p *Periph) mmio.RM32[PMCR]       { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PA0SO} }
func PA1SO_(p *Periph) mmio.RM32[PMCR]       { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PA1SO} }
func PC2SO_(p *Periph) mmio.RM32[PMCR]       { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PC2SO} }
func PC3SO_(p *Periph) mmio.RM32[PMCR]       { return mmio.RM32[PMCR]{R: &p.PMCR, Mask: PC3SO} }

type CCCSR uint32

func EN_(p *Periph) mmio.RM32[CCCSR]    { return mmio.RM32[CCCSR]{R: &p.CCCSR, Mask: EN} }
func CS_(p *Periph) mmio.RM32[CCCSR]    { return mmio.RM32[CCCSR]{R: &p.CCCSR, Mask: CS} }
func READY_(p *Periph) mmio.RM32[CCCSR] { return mmio.RM32[CCCSR]{R: &p.CCCSR, Mask: READY} }
func HSLV_(p *Periph) mmio.RM32[CCCSR]  { return mmio.RM32[CCCSR]{R: &p.CCCSR, Mask: HSLV} }

type CCVR uint32

func NCV_(p *Periph) mmio.RM32[CCVR] { return mmio.RM32[CCVR]{R: &p.CCVR, Mask: NCV} }
func PCV_(p *Periph) mmio.RM32[CCVR] { return mmio.RM32[CCVR]{R: &p.CCVR, Mask: PCV} }

type CCCR uint32

func NCC_(p *Periph) mmio.RM32[CCCR] { return mmio.RM32[CCCR]{R: &p.CCCR, Mask: NCC} }
func PCC_(p *Periph) mmio.RM32[CCCR] { return mmio.RM32[CCCR]{R: &p.CCCR, Mask: PCC} }

type PWRCR uint32

func ODEN_(p *Periph) mmio.RM32[PWRCR] { return mmio.RM32[PWRCR]{R: &p.PWRCR, Mask: ODEN} }

type PKGR uint32

func PKG_(p *Periph) mmio.RM32[PKGR] { return mmio.RM32[PKGR]{R: &p.PKGR, Mask: PKG} }

type UR0 uint32

func BKS_(p *Periph) mmio.RM32[UR0] { return mmio.RM32[UR0]{R: &p.UR0, Mask: BKS} }
func RDP_(p *Periph) mmio.RM32[UR0] { return mmio.RM32[UR0]{R: &p.UR0, Mask: RDP} }

type UR2 uint32

func BORH_(p *Periph) mmio.RM32[UR2]      { return mmio.RM32[UR2]{R: &p.UR2, Mask: BORH} }
func BOOT_ADD0_(p *Periph) mmio.RM32[UR2] { return mmio.RM32[UR2]{R: &p.UR2, Mask: BOOT_ADD0} }

type UR3 uint32

func BOOT_ADD1_(p *Periph) mmio.RM32[UR3] { return mmio.RM32[UR3]{R: &p.UR3, Mask: BOOT_ADD1} }

type UR4 uint32

func MEPAD_1_(p *Periph) mmio.RM32[UR4] { return mmio.RM32[UR4]{R: &p.UR4, Mask: MEPAD_1} }

type UR5 uint32

func MESAD_1_(p *Periph) mmio.RM32[UR5] { return mmio.RM32[UR5]{R: &p.UR5, Mask: MESAD_1} }
func WRPN_1_(p *Periph) mmio.RM32[UR5]  { return mmio.RM32[UR5]{R: &p.UR5, Mask: WRPN_1} }

type UR6 uint32

func PA_BEG_1_(p *Periph) mmio.RM32[UR6] { return mmio.RM32[UR6]{R: &p.UR6, Mask: PA_BEG_1} }
func PA_END_1_(p *Periph) mmio.RM32[UR6] { return mmio.RM32[UR6]{R: &p.UR6, Mask: PA_END_1} }

type UR7 uint32

func SA_BEG_1_(p *Periph) mmio.RM32[UR7] { return mmio.RM32[UR7]{R: &p.UR7, Mask: SA_BEG_1} }
func SA_END_1_(p *Periph) mmio.RM32[UR7] { return mmio.RM32[UR7]{R: &p.UR7, Mask: SA_END_1} }

type UR8 uint32

func MEPAD_2_(p *Periph) mmio.RM32[UR8] { return mmio.RM32[UR8]{R: &p.UR8, Mask: MEPAD_2} }
func MESAD_2_(p *Periph) mmio.RM32[UR8] { return mmio.RM32[UR8]{R: &p.UR8, Mask: MESAD_2} }

type UR9 uint32

func WRPN_2_(p *Periph) mmio.RM32[UR9]   { return mmio.RM32[UR9]{R: &p.UR9, Mask: WRPN_2} }
func PA_BEG_2_(p *Periph) mmio.RM32[UR9] { return mmio.RM32[UR9]{R: &p.UR9, Mask: PA_BEG_2} }

type UR10 uint32

func PA_END_2_(p *Periph) mmio.RM32[UR10] { return mmio.RM32[UR10]{R: &p.UR10, Mask: PA_END_2} }
func SA_BEG_2_(p *Periph) mmio.RM32[UR10] { return mmio.RM32[UR10]{R: &p.UR10, Mask: SA_BEG_2} }

type UR11 uint32

func SA_END_2_(p *Periph) mmio.RM32[UR11] { return mmio.RM32[UR11]{R: &p.UR11, Mask: SA_END_2} }
func IWDG1M_(p *Periph) mmio.RM32[UR11]   { return mmio.RM32[UR11]{R: &p.UR11, Mask: IWDG1M} }

type UR12 uint32

func SECURE_(p *Periph) mmio.RM32[UR12] { return mmio.RM32[UR12]{R: &p.UR12, Mask: SECURE} }

type UR13 uint32

func SDRS_(p *Periph) mmio.RM32[UR13]    { return mmio.RM32[UR13]{R: &p.UR13, Mask: SDRS} }
func D1SBRST_(p *Periph) mmio.RM32[UR13] { return mmio.RM32[UR13]{R: &p.UR13, Mask: D1SBRST} }

type UR14 uint32

func D1STPRST_(p *Periph) mmio.RM32[UR14] { return mmio.RM32[UR14]{R: &p.UR14, Mask: D1STPRST} }

type UR15 uint32

func FZIWDGSTB_(p *Periph) mmio.RM32[UR15] { return mmio.RM32[UR15]{R: &p.UR15, Mask: FZIWDGSTB} }

type UR16 uint32

func FZIWDGSTP_(p *Periph) mmio.RM32[UR16] { return mmio.RM32[UR16]{R: &p.UR16, Mask: FZIWDGSTP} }
func PKP_(p *Periph) mmio.RM32[UR16]       { return mmio.RM32[UR16]{R: &p.UR16, Mask: PKP} }

type UR17 uint32

func IO_HSLV_(p *Periph) mmio.RM32[UR17] { return mmio.RM32[UR17]{R: &p.UR17, Mask: IO_HSLV} }
